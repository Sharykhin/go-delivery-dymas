// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/Sharykhin/go-delivery-dymas/order/domain.OrderRepository -o order_repository_mock_test.go -n OrderRepositoryMock -p order_mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_domain "github.com/Sharykhin/go-delivery-dymas/order/domain"
	"github.com/gojuno/minimock/v3"
)

// OrderRepositoryMock implements domain.OrderRepository
type OrderRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetOrderByID          func(ctx context.Context, orderID string) (op1 *mm_domain.Order, err error)
	inspectFuncGetOrderByID   func(ctx context.Context, orderID string)
	afterGetOrderByIDCounter  uint64
	beforeGetOrderByIDCounter uint64
	GetOrderByIDMock          mOrderRepositoryMockGetOrderByID

	funcGetOrderValidationByID          func(ctx context.Context, orderID string) (op1 *mm_domain.OrderValidation, err error)
	inspectFuncGetOrderValidationByID   func(ctx context.Context, orderID string)
	afterGetOrderValidationByIDCounter  uint64
	beforeGetOrderValidationByIDCounter uint64
	GetOrderValidationByIDMock          mOrderRepositoryMockGetOrderValidationByID

	funcSaveOrder          func(ctx context.Context, order *mm_domain.Order) (op1 *mm_domain.Order, err error)
	inspectFuncSaveOrder   func(ctx context.Context, order *mm_domain.Order)
	afterSaveOrderCounter  uint64
	beforeSaveOrderCounter uint64
	SaveOrderMock          mOrderRepositoryMockSaveOrder

	funcSaveOrderValidation          func(ctx context.Context, orderValidation *mm_domain.OrderValidation) (err error)
	inspectFuncSaveOrderValidation   func(ctx context.Context, orderValidation *mm_domain.OrderValidation)
	afterSaveOrderValidationCounter  uint64
	beforeSaveOrderValidationCounter uint64
	SaveOrderValidationMock          mOrderRepositoryMockSaveOrderValidation

	funcUpdateOrder          func(ctx context.Context, order *mm_domain.Order) (err error)
	inspectFuncUpdateOrder   func(ctx context.Context, order *mm_domain.Order)
	afterUpdateOrderCounter  uint64
	beforeUpdateOrderCounter uint64
	UpdateOrderMock          mOrderRepositoryMockUpdateOrder

	funcUpdateOrderValidation          func(ctx context.Context, orderValidation *mm_domain.OrderValidation) (err error)
	inspectFuncUpdateOrderValidation   func(ctx context.Context, orderValidation *mm_domain.OrderValidation)
	afterUpdateOrderValidationCounter  uint64
	beforeUpdateOrderValidationCounter uint64
	UpdateOrderValidationMock          mOrderRepositoryMockUpdateOrderValidation
}

// NewOrderRepositoryMock returns a mock for domain.OrderRepository
func NewOrderRepositoryMock(t minimock.Tester) *OrderRepositoryMock {
	m := &OrderRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetOrderByIDMock = mOrderRepositoryMockGetOrderByID{mock: m}
	m.GetOrderByIDMock.callArgs = []*OrderRepositoryMockGetOrderByIDParams{}

	m.GetOrderValidationByIDMock = mOrderRepositoryMockGetOrderValidationByID{mock: m}
	m.GetOrderValidationByIDMock.callArgs = []*OrderRepositoryMockGetOrderValidationByIDParams{}

	m.SaveOrderMock = mOrderRepositoryMockSaveOrder{mock: m}
	m.SaveOrderMock.callArgs = []*OrderRepositoryMockSaveOrderParams{}

	m.SaveOrderValidationMock = mOrderRepositoryMockSaveOrderValidation{mock: m}
	m.SaveOrderValidationMock.callArgs = []*OrderRepositoryMockSaveOrderValidationParams{}

	m.UpdateOrderMock = mOrderRepositoryMockUpdateOrder{mock: m}
	m.UpdateOrderMock.callArgs = []*OrderRepositoryMockUpdateOrderParams{}

	m.UpdateOrderValidationMock = mOrderRepositoryMockUpdateOrderValidation{mock: m}
	m.UpdateOrderValidationMock.callArgs = []*OrderRepositoryMockUpdateOrderValidationParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderRepositoryMockGetOrderByID struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetOrderByIDExpectation
	expectations       []*OrderRepositoryMockGetOrderByIDExpectation

	callArgs []*OrderRepositoryMockGetOrderByIDParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockGetOrderByIDExpectation specifies expectation struct of the OrderRepository.GetOrderByID
type OrderRepositoryMockGetOrderByIDExpectation struct {
	mock      *OrderRepositoryMock
	params    *OrderRepositoryMockGetOrderByIDParams
	paramPtrs *OrderRepositoryMockGetOrderByIDParamPtrs
	results   *OrderRepositoryMockGetOrderByIDResults
	Counter   uint64
}

// OrderRepositoryMockGetOrderByIDParams contains parameters of the OrderRepository.GetOrderByID
type OrderRepositoryMockGetOrderByIDParams struct {
	ctx     context.Context
	orderID string
}

// OrderRepositoryMockGetOrderByIDParamPtrs contains pointers to parameters of the OrderRepository.GetOrderByID
type OrderRepositoryMockGetOrderByIDParamPtrs struct {
	ctx     *context.Context
	orderID *string
}

// OrderRepositoryMockGetOrderByIDResults contains results of the OrderRepository.GetOrderByID
type OrderRepositoryMockGetOrderByIDResults struct {
	op1 *mm_domain.Order
	err error
}

// Expect sets up expected params for OrderRepository.GetOrderByID
func (mmGetOrderByID *mOrderRepositoryMockGetOrderByID) Expect(ctx context.Context, orderID string) *mOrderRepositoryMockGetOrderByID {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepositoryMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &OrderRepositoryMockGetOrderByIDExpectation{}
	}

	if mmGetOrderByID.defaultExpectation.paramPtrs != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepositoryMock.GetOrderByID mock is already set by ExpectParams functions")
	}

	mmGetOrderByID.defaultExpectation.params = &OrderRepositoryMockGetOrderByIDParams{ctx, orderID}
	for _, e := range mmGetOrderByID.expectations {
		if minimock.Equal(e.params, mmGetOrderByID.defaultExpectation.params) {
			mmGetOrderByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrderByID.defaultExpectation.params)
		}
	}

	return mmGetOrderByID
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.GetOrderByID
func (mmGetOrderByID *mOrderRepositoryMockGetOrderByID) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetOrderByID {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepositoryMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &OrderRepositoryMockGetOrderByIDExpectation{}
	}

	if mmGetOrderByID.defaultExpectation.params != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepositoryMock.GetOrderByID mock is already set by Expect")
	}

	if mmGetOrderByID.defaultExpectation.paramPtrs == nil {
		mmGetOrderByID.defaultExpectation.paramPtrs = &OrderRepositoryMockGetOrderByIDParamPtrs{}
	}
	mmGetOrderByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetOrderByID
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderRepository.GetOrderByID
func (mmGetOrderByID *mOrderRepositoryMockGetOrderByID) ExpectOrderIDParam2(orderID string) *mOrderRepositoryMockGetOrderByID {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepositoryMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &OrderRepositoryMockGetOrderByIDExpectation{}
	}

	if mmGetOrderByID.defaultExpectation.params != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepositoryMock.GetOrderByID mock is already set by Expect")
	}

	if mmGetOrderByID.defaultExpectation.paramPtrs == nil {
		mmGetOrderByID.defaultExpectation.paramPtrs = &OrderRepositoryMockGetOrderByIDParamPtrs{}
	}
	mmGetOrderByID.defaultExpectation.paramPtrs.orderID = &orderID

	return mmGetOrderByID
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetOrderByID
func (mmGetOrderByID *mOrderRepositoryMockGetOrderByID) Inspect(f func(ctx context.Context, orderID string)) *mOrderRepositoryMockGetOrderByID {
	if mmGetOrderByID.mock.inspectFuncGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetOrderByID")
	}

	mmGetOrderByID.mock.inspectFuncGetOrderByID = f

	return mmGetOrderByID
}

// Return sets up results that will be returned by OrderRepository.GetOrderByID
func (mmGetOrderByID *mOrderRepositoryMockGetOrderByID) Return(op1 *mm_domain.Order, err error) *OrderRepositoryMock {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepositoryMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &OrderRepositoryMockGetOrderByIDExpectation{mock: mmGetOrderByID.mock}
	}
	mmGetOrderByID.defaultExpectation.results = &OrderRepositoryMockGetOrderByIDResults{op1, err}
	return mmGetOrderByID.mock
}

// Set uses given function f to mock the OrderRepository.GetOrderByID method
func (mmGetOrderByID *mOrderRepositoryMockGetOrderByID) Set(f func(ctx context.Context, orderID string) (op1 *mm_domain.Order, err error)) *OrderRepositoryMock {
	if mmGetOrderByID.defaultExpectation != nil {
		mmGetOrderByID.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetOrderByID method")
	}

	if len(mmGetOrderByID.expectations) > 0 {
		mmGetOrderByID.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetOrderByID method")
	}

	mmGetOrderByID.mock.funcGetOrderByID = f
	return mmGetOrderByID.mock
}

// When sets expectation for the OrderRepository.GetOrderByID which will trigger the result defined by the following
// Then helper
func (mmGetOrderByID *mOrderRepositoryMockGetOrderByID) When(ctx context.Context, orderID string) *OrderRepositoryMockGetOrderByIDExpectation {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepositoryMock.GetOrderByID mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetOrderByIDExpectation{
		mock:   mmGetOrderByID.mock,
		params: &OrderRepositoryMockGetOrderByIDParams{ctx, orderID},
	}
	mmGetOrderByID.expectations = append(mmGetOrderByID.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.GetOrderByID return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetOrderByIDExpectation) Then(op1 *mm_domain.Order, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetOrderByIDResults{op1, err}
	return e.mock
}

// GetOrderByID implements domain.OrderRepository
func (mmGetOrderByID *OrderRepositoryMock) GetOrderByID(ctx context.Context, orderID string) (op1 *mm_domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrderByID.beforeGetOrderByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderByID.afterGetOrderByIDCounter, 1)

	if mmGetOrderByID.inspectFuncGetOrderByID != nil {
		mmGetOrderByID.inspectFuncGetOrderByID(ctx, orderID)
	}

	mm_params := OrderRepositoryMockGetOrderByIDParams{ctx, orderID}

	// Record call args
	mmGetOrderByID.GetOrderByIDMock.mutex.Lock()
	mmGetOrderByID.GetOrderByIDMock.callArgs = append(mmGetOrderByID.GetOrderByIDMock.callArgs, &mm_params)
	mmGetOrderByID.GetOrderByIDMock.mutex.Unlock()

	for _, e := range mmGetOrderByID.GetOrderByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrderByID.GetOrderByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderByID.GetOrderByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockGetOrderByIDParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrderByID.t.Errorf("OrderRepositoryMock.GetOrderByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetOrderByID.t.Errorf("OrderRepositoryMock.GetOrderByID got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrderByID.t.Errorf("OrderRepositoryMock.GetOrderByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderByID.t.Fatal("No results are set for the OrderRepositoryMock.GetOrderByID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrderByID.funcGetOrderByID != nil {
		return mmGetOrderByID.funcGetOrderByID(ctx, orderID)
	}
	mmGetOrderByID.t.Fatalf("Unexpected call to OrderRepositoryMock.GetOrderByID. %v %v", ctx, orderID)
	return
}

// GetOrderByIDAfterCounter returns a count of finished OrderRepositoryMock.GetOrderByID invocations
func (mmGetOrderByID *OrderRepositoryMock) GetOrderByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderByID.afterGetOrderByIDCounter)
}

// GetOrderByIDBeforeCounter returns a count of OrderRepositoryMock.GetOrderByID invocations
func (mmGetOrderByID *OrderRepositoryMock) GetOrderByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderByID.beforeGetOrderByIDCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetOrderByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrderByID *mOrderRepositoryMockGetOrderByID) Calls() []*OrderRepositoryMockGetOrderByIDParams {
	mmGetOrderByID.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetOrderByIDParams, len(mmGetOrderByID.callArgs))
	copy(argCopy, mmGetOrderByID.callArgs)

	mmGetOrderByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderByIDDone returns true if the count of the GetOrderByID invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetOrderByIDDone() bool {
	for _, e := range m.GetOrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderByID != nil && mm_atomic.LoadUint64(&m.afterGetOrderByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOrderByIDInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetOrderByIDInspect() {
	for _, e := range m.GetOrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetOrderByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderByIDCounter) < 1 {
		if m.GetOrderByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.GetOrderByID")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetOrderByID with params: %#v", *m.GetOrderByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderByID != nil && mm_atomic.LoadUint64(&m.afterGetOrderByIDCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.GetOrderByID")
	}
}

type mOrderRepositoryMockGetOrderValidationByID struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetOrderValidationByIDExpectation
	expectations       []*OrderRepositoryMockGetOrderValidationByIDExpectation

	callArgs []*OrderRepositoryMockGetOrderValidationByIDParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockGetOrderValidationByIDExpectation specifies expectation struct of the OrderRepository.GetOrderValidationByID
type OrderRepositoryMockGetOrderValidationByIDExpectation struct {
	mock      *OrderRepositoryMock
	params    *OrderRepositoryMockGetOrderValidationByIDParams
	paramPtrs *OrderRepositoryMockGetOrderValidationByIDParamPtrs
	results   *OrderRepositoryMockGetOrderValidationByIDResults
	Counter   uint64
}

// OrderRepositoryMockGetOrderValidationByIDParams contains parameters of the OrderRepository.GetOrderValidationByID
type OrderRepositoryMockGetOrderValidationByIDParams struct {
	ctx     context.Context
	orderID string
}

// OrderRepositoryMockGetOrderValidationByIDParamPtrs contains pointers to parameters of the OrderRepository.GetOrderValidationByID
type OrderRepositoryMockGetOrderValidationByIDParamPtrs struct {
	ctx     *context.Context
	orderID *string
}

// OrderRepositoryMockGetOrderValidationByIDResults contains results of the OrderRepository.GetOrderValidationByID
type OrderRepositoryMockGetOrderValidationByIDResults struct {
	op1 *mm_domain.OrderValidation
	err error
}

// Expect sets up expected params for OrderRepository.GetOrderValidationByID
func (mmGetOrderValidationByID *mOrderRepositoryMockGetOrderValidationByID) Expect(ctx context.Context, orderID string) *mOrderRepositoryMockGetOrderValidationByID {
	if mmGetOrderValidationByID.mock.funcGetOrderValidationByID != nil {
		mmGetOrderValidationByID.mock.t.Fatalf("OrderRepositoryMock.GetOrderValidationByID mock is already set by Set")
	}

	if mmGetOrderValidationByID.defaultExpectation == nil {
		mmGetOrderValidationByID.defaultExpectation = &OrderRepositoryMockGetOrderValidationByIDExpectation{}
	}

	if mmGetOrderValidationByID.defaultExpectation.paramPtrs != nil {
		mmGetOrderValidationByID.mock.t.Fatalf("OrderRepositoryMock.GetOrderValidationByID mock is already set by ExpectParams functions")
	}

	mmGetOrderValidationByID.defaultExpectation.params = &OrderRepositoryMockGetOrderValidationByIDParams{ctx, orderID}
	for _, e := range mmGetOrderValidationByID.expectations {
		if minimock.Equal(e.params, mmGetOrderValidationByID.defaultExpectation.params) {
			mmGetOrderValidationByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrderValidationByID.defaultExpectation.params)
		}
	}

	return mmGetOrderValidationByID
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.GetOrderValidationByID
func (mmGetOrderValidationByID *mOrderRepositoryMockGetOrderValidationByID) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetOrderValidationByID {
	if mmGetOrderValidationByID.mock.funcGetOrderValidationByID != nil {
		mmGetOrderValidationByID.mock.t.Fatalf("OrderRepositoryMock.GetOrderValidationByID mock is already set by Set")
	}

	if mmGetOrderValidationByID.defaultExpectation == nil {
		mmGetOrderValidationByID.defaultExpectation = &OrderRepositoryMockGetOrderValidationByIDExpectation{}
	}

	if mmGetOrderValidationByID.defaultExpectation.params != nil {
		mmGetOrderValidationByID.mock.t.Fatalf("OrderRepositoryMock.GetOrderValidationByID mock is already set by Expect")
	}

	if mmGetOrderValidationByID.defaultExpectation.paramPtrs == nil {
		mmGetOrderValidationByID.defaultExpectation.paramPtrs = &OrderRepositoryMockGetOrderValidationByIDParamPtrs{}
	}
	mmGetOrderValidationByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetOrderValidationByID
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderRepository.GetOrderValidationByID
func (mmGetOrderValidationByID *mOrderRepositoryMockGetOrderValidationByID) ExpectOrderIDParam2(orderID string) *mOrderRepositoryMockGetOrderValidationByID {
	if mmGetOrderValidationByID.mock.funcGetOrderValidationByID != nil {
		mmGetOrderValidationByID.mock.t.Fatalf("OrderRepositoryMock.GetOrderValidationByID mock is already set by Set")
	}

	if mmGetOrderValidationByID.defaultExpectation == nil {
		mmGetOrderValidationByID.defaultExpectation = &OrderRepositoryMockGetOrderValidationByIDExpectation{}
	}

	if mmGetOrderValidationByID.defaultExpectation.params != nil {
		mmGetOrderValidationByID.mock.t.Fatalf("OrderRepositoryMock.GetOrderValidationByID mock is already set by Expect")
	}

	if mmGetOrderValidationByID.defaultExpectation.paramPtrs == nil {
		mmGetOrderValidationByID.defaultExpectation.paramPtrs = &OrderRepositoryMockGetOrderValidationByIDParamPtrs{}
	}
	mmGetOrderValidationByID.defaultExpectation.paramPtrs.orderID = &orderID

	return mmGetOrderValidationByID
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetOrderValidationByID
func (mmGetOrderValidationByID *mOrderRepositoryMockGetOrderValidationByID) Inspect(f func(ctx context.Context, orderID string)) *mOrderRepositoryMockGetOrderValidationByID {
	if mmGetOrderValidationByID.mock.inspectFuncGetOrderValidationByID != nil {
		mmGetOrderValidationByID.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetOrderValidationByID")
	}

	mmGetOrderValidationByID.mock.inspectFuncGetOrderValidationByID = f

	return mmGetOrderValidationByID
}

// Return sets up results that will be returned by OrderRepository.GetOrderValidationByID
func (mmGetOrderValidationByID *mOrderRepositoryMockGetOrderValidationByID) Return(op1 *mm_domain.OrderValidation, err error) *OrderRepositoryMock {
	if mmGetOrderValidationByID.mock.funcGetOrderValidationByID != nil {
		mmGetOrderValidationByID.mock.t.Fatalf("OrderRepositoryMock.GetOrderValidationByID mock is already set by Set")
	}

	if mmGetOrderValidationByID.defaultExpectation == nil {
		mmGetOrderValidationByID.defaultExpectation = &OrderRepositoryMockGetOrderValidationByIDExpectation{mock: mmGetOrderValidationByID.mock}
	}
	mmGetOrderValidationByID.defaultExpectation.results = &OrderRepositoryMockGetOrderValidationByIDResults{op1, err}
	return mmGetOrderValidationByID.mock
}

// Set uses given function f to mock the OrderRepository.GetOrderValidationByID method
func (mmGetOrderValidationByID *mOrderRepositoryMockGetOrderValidationByID) Set(f func(ctx context.Context, orderID string) (op1 *mm_domain.OrderValidation, err error)) *OrderRepositoryMock {
	if mmGetOrderValidationByID.defaultExpectation != nil {
		mmGetOrderValidationByID.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetOrderValidationByID method")
	}

	if len(mmGetOrderValidationByID.expectations) > 0 {
		mmGetOrderValidationByID.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetOrderValidationByID method")
	}

	mmGetOrderValidationByID.mock.funcGetOrderValidationByID = f
	return mmGetOrderValidationByID.mock
}

// When sets expectation for the OrderRepository.GetOrderValidationByID which will trigger the result defined by the following
// Then helper
func (mmGetOrderValidationByID *mOrderRepositoryMockGetOrderValidationByID) When(ctx context.Context, orderID string) *OrderRepositoryMockGetOrderValidationByIDExpectation {
	if mmGetOrderValidationByID.mock.funcGetOrderValidationByID != nil {
		mmGetOrderValidationByID.mock.t.Fatalf("OrderRepositoryMock.GetOrderValidationByID mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetOrderValidationByIDExpectation{
		mock:   mmGetOrderValidationByID.mock,
		params: &OrderRepositoryMockGetOrderValidationByIDParams{ctx, orderID},
	}
	mmGetOrderValidationByID.expectations = append(mmGetOrderValidationByID.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.GetOrderValidationByID return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetOrderValidationByIDExpectation) Then(op1 *mm_domain.OrderValidation, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetOrderValidationByIDResults{op1, err}
	return e.mock
}

// GetOrderValidationByID implements domain.OrderRepository
func (mmGetOrderValidationByID *OrderRepositoryMock) GetOrderValidationByID(ctx context.Context, orderID string) (op1 *mm_domain.OrderValidation, err error) {
	mm_atomic.AddUint64(&mmGetOrderValidationByID.beforeGetOrderValidationByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderValidationByID.afterGetOrderValidationByIDCounter, 1)

	if mmGetOrderValidationByID.inspectFuncGetOrderValidationByID != nil {
		mmGetOrderValidationByID.inspectFuncGetOrderValidationByID(ctx, orderID)
	}

	mm_params := OrderRepositoryMockGetOrderValidationByIDParams{ctx, orderID}

	// Record call args
	mmGetOrderValidationByID.GetOrderValidationByIDMock.mutex.Lock()
	mmGetOrderValidationByID.GetOrderValidationByIDMock.callArgs = append(mmGetOrderValidationByID.GetOrderValidationByIDMock.callArgs, &mm_params)
	mmGetOrderValidationByID.GetOrderValidationByIDMock.mutex.Unlock()

	for _, e := range mmGetOrderValidationByID.GetOrderValidationByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrderValidationByID.GetOrderValidationByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderValidationByID.GetOrderValidationByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrderValidationByID.GetOrderValidationByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrderValidationByID.GetOrderValidationByIDMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockGetOrderValidationByIDParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrderValidationByID.t.Errorf("OrderRepositoryMock.GetOrderValidationByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetOrderValidationByID.t.Errorf("OrderRepositoryMock.GetOrderValidationByID got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrderValidationByID.t.Errorf("OrderRepositoryMock.GetOrderValidationByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrderValidationByID.GetOrderValidationByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderValidationByID.t.Fatal("No results are set for the OrderRepositoryMock.GetOrderValidationByID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrderValidationByID.funcGetOrderValidationByID != nil {
		return mmGetOrderValidationByID.funcGetOrderValidationByID(ctx, orderID)
	}
	mmGetOrderValidationByID.t.Fatalf("Unexpected call to OrderRepositoryMock.GetOrderValidationByID. %v %v", ctx, orderID)
	return
}

// GetOrderValidationByIDAfterCounter returns a count of finished OrderRepositoryMock.GetOrderValidationByID invocations
func (mmGetOrderValidationByID *OrderRepositoryMock) GetOrderValidationByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderValidationByID.afterGetOrderValidationByIDCounter)
}

// GetOrderValidationByIDBeforeCounter returns a count of OrderRepositoryMock.GetOrderValidationByID invocations
func (mmGetOrderValidationByID *OrderRepositoryMock) GetOrderValidationByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderValidationByID.beforeGetOrderValidationByIDCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetOrderValidationByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrderValidationByID *mOrderRepositoryMockGetOrderValidationByID) Calls() []*OrderRepositoryMockGetOrderValidationByIDParams {
	mmGetOrderValidationByID.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetOrderValidationByIDParams, len(mmGetOrderValidationByID.callArgs))
	copy(argCopy, mmGetOrderValidationByID.callArgs)

	mmGetOrderValidationByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderValidationByIDDone returns true if the count of the GetOrderValidationByID invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetOrderValidationByIDDone() bool {
	for _, e := range m.GetOrderValidationByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderValidationByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderValidationByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderValidationByID != nil && mm_atomic.LoadUint64(&m.afterGetOrderValidationByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOrderValidationByIDInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetOrderValidationByIDInspect() {
	for _, e := range m.GetOrderValidationByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetOrderValidationByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderValidationByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderValidationByIDCounter) < 1 {
		if m.GetOrderValidationByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.GetOrderValidationByID")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetOrderValidationByID with params: %#v", *m.GetOrderValidationByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderValidationByID != nil && mm_atomic.LoadUint64(&m.afterGetOrderValidationByIDCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.GetOrderValidationByID")
	}
}

type mOrderRepositoryMockSaveOrder struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockSaveOrderExpectation
	expectations       []*OrderRepositoryMockSaveOrderExpectation

	callArgs []*OrderRepositoryMockSaveOrderParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockSaveOrderExpectation specifies expectation struct of the OrderRepository.SaveOrder
type OrderRepositoryMockSaveOrderExpectation struct {
	mock      *OrderRepositoryMock
	params    *OrderRepositoryMockSaveOrderParams
	paramPtrs *OrderRepositoryMockSaveOrderParamPtrs
	results   *OrderRepositoryMockSaveOrderResults
	Counter   uint64
}

// OrderRepositoryMockSaveOrderParams contains parameters of the OrderRepository.SaveOrder
type OrderRepositoryMockSaveOrderParams struct {
	ctx   context.Context
	order *mm_domain.Order
}

// OrderRepositoryMockSaveOrderParamPtrs contains pointers to parameters of the OrderRepository.SaveOrder
type OrderRepositoryMockSaveOrderParamPtrs struct {
	ctx   *context.Context
	order **mm_domain.Order
}

// OrderRepositoryMockSaveOrderResults contains results of the OrderRepository.SaveOrder
type OrderRepositoryMockSaveOrderResults struct {
	op1 *mm_domain.Order
	err error
}

// Expect sets up expected params for OrderRepository.SaveOrder
func (mmSaveOrder *mOrderRepositoryMockSaveOrder) Expect(ctx context.Context, order *mm_domain.Order) *mOrderRepositoryMockSaveOrder {
	if mmSaveOrder.mock.funcSaveOrder != nil {
		mmSaveOrder.mock.t.Fatalf("OrderRepositoryMock.SaveOrder mock is already set by Set")
	}

	if mmSaveOrder.defaultExpectation == nil {
		mmSaveOrder.defaultExpectation = &OrderRepositoryMockSaveOrderExpectation{}
	}

	if mmSaveOrder.defaultExpectation.paramPtrs != nil {
		mmSaveOrder.mock.t.Fatalf("OrderRepositoryMock.SaveOrder mock is already set by ExpectParams functions")
	}

	mmSaveOrder.defaultExpectation.params = &OrderRepositoryMockSaveOrderParams{ctx, order}
	for _, e := range mmSaveOrder.expectations {
		if minimock.Equal(e.params, mmSaveOrder.defaultExpectation.params) {
			mmSaveOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveOrder.defaultExpectation.params)
		}
	}

	return mmSaveOrder
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.SaveOrder
func (mmSaveOrder *mOrderRepositoryMockSaveOrder) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockSaveOrder {
	if mmSaveOrder.mock.funcSaveOrder != nil {
		mmSaveOrder.mock.t.Fatalf("OrderRepositoryMock.SaveOrder mock is already set by Set")
	}

	if mmSaveOrder.defaultExpectation == nil {
		mmSaveOrder.defaultExpectation = &OrderRepositoryMockSaveOrderExpectation{}
	}

	if mmSaveOrder.defaultExpectation.params != nil {
		mmSaveOrder.mock.t.Fatalf("OrderRepositoryMock.SaveOrder mock is already set by Expect")
	}

	if mmSaveOrder.defaultExpectation.paramPtrs == nil {
		mmSaveOrder.defaultExpectation.paramPtrs = &OrderRepositoryMockSaveOrderParamPtrs{}
	}
	mmSaveOrder.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSaveOrder
}

// ExpectOrderParam2 sets up expected param order for OrderRepository.SaveOrder
func (mmSaveOrder *mOrderRepositoryMockSaveOrder) ExpectOrderParam2(order *mm_domain.Order) *mOrderRepositoryMockSaveOrder {
	if mmSaveOrder.mock.funcSaveOrder != nil {
		mmSaveOrder.mock.t.Fatalf("OrderRepositoryMock.SaveOrder mock is already set by Set")
	}

	if mmSaveOrder.defaultExpectation == nil {
		mmSaveOrder.defaultExpectation = &OrderRepositoryMockSaveOrderExpectation{}
	}

	if mmSaveOrder.defaultExpectation.params != nil {
		mmSaveOrder.mock.t.Fatalf("OrderRepositoryMock.SaveOrder mock is already set by Expect")
	}

	if mmSaveOrder.defaultExpectation.paramPtrs == nil {
		mmSaveOrder.defaultExpectation.paramPtrs = &OrderRepositoryMockSaveOrderParamPtrs{}
	}
	mmSaveOrder.defaultExpectation.paramPtrs.order = &order

	return mmSaveOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.SaveOrder
func (mmSaveOrder *mOrderRepositoryMockSaveOrder) Inspect(f func(ctx context.Context, order *mm_domain.Order)) *mOrderRepositoryMockSaveOrder {
	if mmSaveOrder.mock.inspectFuncSaveOrder != nil {
		mmSaveOrder.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.SaveOrder")
	}

	mmSaveOrder.mock.inspectFuncSaveOrder = f

	return mmSaveOrder
}

// Return sets up results that will be returned by OrderRepository.SaveOrder
func (mmSaveOrder *mOrderRepositoryMockSaveOrder) Return(op1 *mm_domain.Order, err error) *OrderRepositoryMock {
	if mmSaveOrder.mock.funcSaveOrder != nil {
		mmSaveOrder.mock.t.Fatalf("OrderRepositoryMock.SaveOrder mock is already set by Set")
	}

	if mmSaveOrder.defaultExpectation == nil {
		mmSaveOrder.defaultExpectation = &OrderRepositoryMockSaveOrderExpectation{mock: mmSaveOrder.mock}
	}
	mmSaveOrder.defaultExpectation.results = &OrderRepositoryMockSaveOrderResults{op1, err}
	return mmSaveOrder.mock
}

// Set uses given function f to mock the OrderRepository.SaveOrder method
func (mmSaveOrder *mOrderRepositoryMockSaveOrder) Set(f func(ctx context.Context, order *mm_domain.Order) (op1 *mm_domain.Order, err error)) *OrderRepositoryMock {
	if mmSaveOrder.defaultExpectation != nil {
		mmSaveOrder.mock.t.Fatalf("Default expectation is already set for the OrderRepository.SaveOrder method")
	}

	if len(mmSaveOrder.expectations) > 0 {
		mmSaveOrder.mock.t.Fatalf("Some expectations are already set for the OrderRepository.SaveOrder method")
	}

	mmSaveOrder.mock.funcSaveOrder = f
	return mmSaveOrder.mock
}

// When sets expectation for the OrderRepository.SaveOrder which will trigger the result defined by the following
// Then helper
func (mmSaveOrder *mOrderRepositoryMockSaveOrder) When(ctx context.Context, order *mm_domain.Order) *OrderRepositoryMockSaveOrderExpectation {
	if mmSaveOrder.mock.funcSaveOrder != nil {
		mmSaveOrder.mock.t.Fatalf("OrderRepositoryMock.SaveOrder mock is already set by Set")
	}

	expectation := &OrderRepositoryMockSaveOrderExpectation{
		mock:   mmSaveOrder.mock,
		params: &OrderRepositoryMockSaveOrderParams{ctx, order},
	}
	mmSaveOrder.expectations = append(mmSaveOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.SaveOrder return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockSaveOrderExpectation) Then(op1 *mm_domain.Order, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockSaveOrderResults{op1, err}
	return e.mock
}

// SaveOrder implements domain.OrderRepository
func (mmSaveOrder *OrderRepositoryMock) SaveOrder(ctx context.Context, order *mm_domain.Order) (op1 *mm_domain.Order, err error) {
	mm_atomic.AddUint64(&mmSaveOrder.beforeSaveOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveOrder.afterSaveOrderCounter, 1)

	if mmSaveOrder.inspectFuncSaveOrder != nil {
		mmSaveOrder.inspectFuncSaveOrder(ctx, order)
	}

	mm_params := OrderRepositoryMockSaveOrderParams{ctx, order}

	// Record call args
	mmSaveOrder.SaveOrderMock.mutex.Lock()
	mmSaveOrder.SaveOrderMock.callArgs = append(mmSaveOrder.SaveOrderMock.callArgs, &mm_params)
	mmSaveOrder.SaveOrderMock.mutex.Unlock()

	for _, e := range mmSaveOrder.SaveOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmSaveOrder.SaveOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveOrder.SaveOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveOrder.SaveOrderMock.defaultExpectation.params
		mm_want_ptrs := mmSaveOrder.SaveOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockSaveOrderParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveOrder.t.Errorf("OrderRepositoryMock.SaveOrder got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmSaveOrder.t.Errorf("OrderRepositoryMock.SaveOrder got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveOrder.t.Errorf("OrderRepositoryMock.SaveOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveOrder.SaveOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveOrder.t.Fatal("No results are set for the OrderRepositoryMock.SaveOrder")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmSaveOrder.funcSaveOrder != nil {
		return mmSaveOrder.funcSaveOrder(ctx, order)
	}
	mmSaveOrder.t.Fatalf("Unexpected call to OrderRepositoryMock.SaveOrder. %v %v", ctx, order)
	return
}

// SaveOrderAfterCounter returns a count of finished OrderRepositoryMock.SaveOrder invocations
func (mmSaveOrder *OrderRepositoryMock) SaveOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveOrder.afterSaveOrderCounter)
}

// SaveOrderBeforeCounter returns a count of OrderRepositoryMock.SaveOrder invocations
func (mmSaveOrder *OrderRepositoryMock) SaveOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveOrder.beforeSaveOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.SaveOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveOrder *mOrderRepositoryMockSaveOrder) Calls() []*OrderRepositoryMockSaveOrderParams {
	mmSaveOrder.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockSaveOrderParams, len(mmSaveOrder.callArgs))
	copy(argCopy, mmSaveOrder.callArgs)

	mmSaveOrder.mutex.RUnlock()

	return argCopy
}

// MinimockSaveOrderDone returns true if the count of the SaveOrder invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockSaveOrderDone() bool {
	for _, e := range m.SaveOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveOrder != nil && mm_atomic.LoadUint64(&m.afterSaveOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveOrderInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockSaveOrderInspect() {
	for _, e := range m.SaveOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.SaveOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveOrderCounter) < 1 {
		if m.SaveOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.SaveOrder")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.SaveOrder with params: %#v", *m.SaveOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveOrder != nil && mm_atomic.LoadUint64(&m.afterSaveOrderCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.SaveOrder")
	}
}

type mOrderRepositoryMockSaveOrderValidation struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockSaveOrderValidationExpectation
	expectations       []*OrderRepositoryMockSaveOrderValidationExpectation

	callArgs []*OrderRepositoryMockSaveOrderValidationParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockSaveOrderValidationExpectation specifies expectation struct of the OrderRepository.SaveOrderValidation
type OrderRepositoryMockSaveOrderValidationExpectation struct {
	mock      *OrderRepositoryMock
	params    *OrderRepositoryMockSaveOrderValidationParams
	paramPtrs *OrderRepositoryMockSaveOrderValidationParamPtrs
	results   *OrderRepositoryMockSaveOrderValidationResults
	Counter   uint64
}

// OrderRepositoryMockSaveOrderValidationParams contains parameters of the OrderRepository.SaveOrderValidation
type OrderRepositoryMockSaveOrderValidationParams struct {
	ctx             context.Context
	orderValidation *mm_domain.OrderValidation
}

// OrderRepositoryMockSaveOrderValidationParamPtrs contains pointers to parameters of the OrderRepository.SaveOrderValidation
type OrderRepositoryMockSaveOrderValidationParamPtrs struct {
	ctx             *context.Context
	orderValidation **mm_domain.OrderValidation
}

// OrderRepositoryMockSaveOrderValidationResults contains results of the OrderRepository.SaveOrderValidation
type OrderRepositoryMockSaveOrderValidationResults struct {
	err error
}

// Expect sets up expected params for OrderRepository.SaveOrderValidation
func (mmSaveOrderValidation *mOrderRepositoryMockSaveOrderValidation) Expect(ctx context.Context, orderValidation *mm_domain.OrderValidation) *mOrderRepositoryMockSaveOrderValidation {
	if mmSaveOrderValidation.mock.funcSaveOrderValidation != nil {
		mmSaveOrderValidation.mock.t.Fatalf("OrderRepositoryMock.SaveOrderValidation mock is already set by Set")
	}

	if mmSaveOrderValidation.defaultExpectation == nil {
		mmSaveOrderValidation.defaultExpectation = &OrderRepositoryMockSaveOrderValidationExpectation{}
	}

	if mmSaveOrderValidation.defaultExpectation.paramPtrs != nil {
		mmSaveOrderValidation.mock.t.Fatalf("OrderRepositoryMock.SaveOrderValidation mock is already set by ExpectParams functions")
	}

	mmSaveOrderValidation.defaultExpectation.params = &OrderRepositoryMockSaveOrderValidationParams{ctx, orderValidation}
	for _, e := range mmSaveOrderValidation.expectations {
		if minimock.Equal(e.params, mmSaveOrderValidation.defaultExpectation.params) {
			mmSaveOrderValidation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveOrderValidation.defaultExpectation.params)
		}
	}

	return mmSaveOrderValidation
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.SaveOrderValidation
func (mmSaveOrderValidation *mOrderRepositoryMockSaveOrderValidation) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockSaveOrderValidation {
	if mmSaveOrderValidation.mock.funcSaveOrderValidation != nil {
		mmSaveOrderValidation.mock.t.Fatalf("OrderRepositoryMock.SaveOrderValidation mock is already set by Set")
	}

	if mmSaveOrderValidation.defaultExpectation == nil {
		mmSaveOrderValidation.defaultExpectation = &OrderRepositoryMockSaveOrderValidationExpectation{}
	}

	if mmSaveOrderValidation.defaultExpectation.params != nil {
		mmSaveOrderValidation.mock.t.Fatalf("OrderRepositoryMock.SaveOrderValidation mock is already set by Expect")
	}

	if mmSaveOrderValidation.defaultExpectation.paramPtrs == nil {
		mmSaveOrderValidation.defaultExpectation.paramPtrs = &OrderRepositoryMockSaveOrderValidationParamPtrs{}
	}
	mmSaveOrderValidation.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSaveOrderValidation
}

// ExpectOrderValidationParam2 sets up expected param orderValidation for OrderRepository.SaveOrderValidation
func (mmSaveOrderValidation *mOrderRepositoryMockSaveOrderValidation) ExpectOrderValidationParam2(orderValidation *mm_domain.OrderValidation) *mOrderRepositoryMockSaveOrderValidation {
	if mmSaveOrderValidation.mock.funcSaveOrderValidation != nil {
		mmSaveOrderValidation.mock.t.Fatalf("OrderRepositoryMock.SaveOrderValidation mock is already set by Set")
	}

	if mmSaveOrderValidation.defaultExpectation == nil {
		mmSaveOrderValidation.defaultExpectation = &OrderRepositoryMockSaveOrderValidationExpectation{}
	}

	if mmSaveOrderValidation.defaultExpectation.params != nil {
		mmSaveOrderValidation.mock.t.Fatalf("OrderRepositoryMock.SaveOrderValidation mock is already set by Expect")
	}

	if mmSaveOrderValidation.defaultExpectation.paramPtrs == nil {
		mmSaveOrderValidation.defaultExpectation.paramPtrs = &OrderRepositoryMockSaveOrderValidationParamPtrs{}
	}
	mmSaveOrderValidation.defaultExpectation.paramPtrs.orderValidation = &orderValidation

	return mmSaveOrderValidation
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.SaveOrderValidation
func (mmSaveOrderValidation *mOrderRepositoryMockSaveOrderValidation) Inspect(f func(ctx context.Context, orderValidation *mm_domain.OrderValidation)) *mOrderRepositoryMockSaveOrderValidation {
	if mmSaveOrderValidation.mock.inspectFuncSaveOrderValidation != nil {
		mmSaveOrderValidation.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.SaveOrderValidation")
	}

	mmSaveOrderValidation.mock.inspectFuncSaveOrderValidation = f

	return mmSaveOrderValidation
}

// Return sets up results that will be returned by OrderRepository.SaveOrderValidation
func (mmSaveOrderValidation *mOrderRepositoryMockSaveOrderValidation) Return(err error) *OrderRepositoryMock {
	if mmSaveOrderValidation.mock.funcSaveOrderValidation != nil {
		mmSaveOrderValidation.mock.t.Fatalf("OrderRepositoryMock.SaveOrderValidation mock is already set by Set")
	}

	if mmSaveOrderValidation.defaultExpectation == nil {
		mmSaveOrderValidation.defaultExpectation = &OrderRepositoryMockSaveOrderValidationExpectation{mock: mmSaveOrderValidation.mock}
	}
	mmSaveOrderValidation.defaultExpectation.results = &OrderRepositoryMockSaveOrderValidationResults{err}
	return mmSaveOrderValidation.mock
}

// Set uses given function f to mock the OrderRepository.SaveOrderValidation method
func (mmSaveOrderValidation *mOrderRepositoryMockSaveOrderValidation) Set(f func(ctx context.Context, orderValidation *mm_domain.OrderValidation) (err error)) *OrderRepositoryMock {
	if mmSaveOrderValidation.defaultExpectation != nil {
		mmSaveOrderValidation.mock.t.Fatalf("Default expectation is already set for the OrderRepository.SaveOrderValidation method")
	}

	if len(mmSaveOrderValidation.expectations) > 0 {
		mmSaveOrderValidation.mock.t.Fatalf("Some expectations are already set for the OrderRepository.SaveOrderValidation method")
	}

	mmSaveOrderValidation.mock.funcSaveOrderValidation = f
	return mmSaveOrderValidation.mock
}

// When sets expectation for the OrderRepository.SaveOrderValidation which will trigger the result defined by the following
// Then helper
func (mmSaveOrderValidation *mOrderRepositoryMockSaveOrderValidation) When(ctx context.Context, orderValidation *mm_domain.OrderValidation) *OrderRepositoryMockSaveOrderValidationExpectation {
	if mmSaveOrderValidation.mock.funcSaveOrderValidation != nil {
		mmSaveOrderValidation.mock.t.Fatalf("OrderRepositoryMock.SaveOrderValidation mock is already set by Set")
	}

	expectation := &OrderRepositoryMockSaveOrderValidationExpectation{
		mock:   mmSaveOrderValidation.mock,
		params: &OrderRepositoryMockSaveOrderValidationParams{ctx, orderValidation},
	}
	mmSaveOrderValidation.expectations = append(mmSaveOrderValidation.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.SaveOrderValidation return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockSaveOrderValidationExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockSaveOrderValidationResults{err}
	return e.mock
}

// SaveOrderValidation implements domain.OrderRepository
func (mmSaveOrderValidation *OrderRepositoryMock) SaveOrderValidation(ctx context.Context, orderValidation *mm_domain.OrderValidation) (err error) {
	mm_atomic.AddUint64(&mmSaveOrderValidation.beforeSaveOrderValidationCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveOrderValidation.afterSaveOrderValidationCounter, 1)

	if mmSaveOrderValidation.inspectFuncSaveOrderValidation != nil {
		mmSaveOrderValidation.inspectFuncSaveOrderValidation(ctx, orderValidation)
	}

	mm_params := OrderRepositoryMockSaveOrderValidationParams{ctx, orderValidation}

	// Record call args
	mmSaveOrderValidation.SaveOrderValidationMock.mutex.Lock()
	mmSaveOrderValidation.SaveOrderValidationMock.callArgs = append(mmSaveOrderValidation.SaveOrderValidationMock.callArgs, &mm_params)
	mmSaveOrderValidation.SaveOrderValidationMock.mutex.Unlock()

	for _, e := range mmSaveOrderValidation.SaveOrderValidationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveOrderValidation.SaveOrderValidationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveOrderValidation.SaveOrderValidationMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveOrderValidation.SaveOrderValidationMock.defaultExpectation.params
		mm_want_ptrs := mmSaveOrderValidation.SaveOrderValidationMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockSaveOrderValidationParams{ctx, orderValidation}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveOrderValidation.t.Errorf("OrderRepositoryMock.SaveOrderValidation got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderValidation != nil && !minimock.Equal(*mm_want_ptrs.orderValidation, mm_got.orderValidation) {
				mmSaveOrderValidation.t.Errorf("OrderRepositoryMock.SaveOrderValidation got unexpected parameter orderValidation, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderValidation, mm_got.orderValidation, minimock.Diff(*mm_want_ptrs.orderValidation, mm_got.orderValidation))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveOrderValidation.t.Errorf("OrderRepositoryMock.SaveOrderValidation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveOrderValidation.SaveOrderValidationMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveOrderValidation.t.Fatal("No results are set for the OrderRepositoryMock.SaveOrderValidation")
		}
		return (*mm_results).err
	}
	if mmSaveOrderValidation.funcSaveOrderValidation != nil {
		return mmSaveOrderValidation.funcSaveOrderValidation(ctx, orderValidation)
	}
	mmSaveOrderValidation.t.Fatalf("Unexpected call to OrderRepositoryMock.SaveOrderValidation. %v %v", ctx, orderValidation)
	return
}

// SaveOrderValidationAfterCounter returns a count of finished OrderRepositoryMock.SaveOrderValidation invocations
func (mmSaveOrderValidation *OrderRepositoryMock) SaveOrderValidationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveOrderValidation.afterSaveOrderValidationCounter)
}

// SaveOrderValidationBeforeCounter returns a count of OrderRepositoryMock.SaveOrderValidation invocations
func (mmSaveOrderValidation *OrderRepositoryMock) SaveOrderValidationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveOrderValidation.beforeSaveOrderValidationCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.SaveOrderValidation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveOrderValidation *mOrderRepositoryMockSaveOrderValidation) Calls() []*OrderRepositoryMockSaveOrderValidationParams {
	mmSaveOrderValidation.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockSaveOrderValidationParams, len(mmSaveOrderValidation.callArgs))
	copy(argCopy, mmSaveOrderValidation.callArgs)

	mmSaveOrderValidation.mutex.RUnlock()

	return argCopy
}

// MinimockSaveOrderValidationDone returns true if the count of the SaveOrderValidation invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockSaveOrderValidationDone() bool {
	for _, e := range m.SaveOrderValidationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveOrderValidationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveOrderValidationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveOrderValidation != nil && mm_atomic.LoadUint64(&m.afterSaveOrderValidationCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveOrderValidationInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockSaveOrderValidationInspect() {
	for _, e := range m.SaveOrderValidationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.SaveOrderValidation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveOrderValidationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveOrderValidationCounter) < 1 {
		if m.SaveOrderValidationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.SaveOrderValidation")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.SaveOrderValidation with params: %#v", *m.SaveOrderValidationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveOrderValidation != nil && mm_atomic.LoadUint64(&m.afterSaveOrderValidationCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.SaveOrderValidation")
	}
}

type mOrderRepositoryMockUpdateOrder struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockUpdateOrderExpectation
	expectations       []*OrderRepositoryMockUpdateOrderExpectation

	callArgs []*OrderRepositoryMockUpdateOrderParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockUpdateOrderExpectation specifies expectation struct of the OrderRepository.UpdateOrder
type OrderRepositoryMockUpdateOrderExpectation struct {
	mock      *OrderRepositoryMock
	params    *OrderRepositoryMockUpdateOrderParams
	paramPtrs *OrderRepositoryMockUpdateOrderParamPtrs
	results   *OrderRepositoryMockUpdateOrderResults
	Counter   uint64
}

// OrderRepositoryMockUpdateOrderParams contains parameters of the OrderRepository.UpdateOrder
type OrderRepositoryMockUpdateOrderParams struct {
	ctx   context.Context
	order *mm_domain.Order
}

// OrderRepositoryMockUpdateOrderParamPtrs contains pointers to parameters of the OrderRepository.UpdateOrder
type OrderRepositoryMockUpdateOrderParamPtrs struct {
	ctx   *context.Context
	order **mm_domain.Order
}

// OrderRepositoryMockUpdateOrderResults contains results of the OrderRepository.UpdateOrder
type OrderRepositoryMockUpdateOrderResults struct {
	err error
}

// Expect sets up expected params for OrderRepository.UpdateOrder
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Expect(ctx context.Context, order *mm_domain.Order) *mOrderRepositoryMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &OrderRepositoryMockUpdateOrderExpectation{}
	}

	if mmUpdateOrder.defaultExpectation.paramPtrs != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by ExpectParams functions")
	}

	mmUpdateOrder.defaultExpectation.params = &OrderRepositoryMockUpdateOrderParams{ctx, order}
	for _, e := range mmUpdateOrder.expectations {
		if minimock.Equal(e.params, mmUpdateOrder.defaultExpectation.params) {
			mmUpdateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrder.defaultExpectation.params)
		}
	}

	return mmUpdateOrder
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.UpdateOrder
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &OrderRepositoryMockUpdateOrderExpectation{}
	}

	if mmUpdateOrder.defaultExpectation.params != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Expect")
	}

	if mmUpdateOrder.defaultExpectation.paramPtrs == nil {
		mmUpdateOrder.defaultExpectation.paramPtrs = &OrderRepositoryMockUpdateOrderParamPtrs{}
	}
	mmUpdateOrder.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateOrder
}

// ExpectOrderParam2 sets up expected param order for OrderRepository.UpdateOrder
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) ExpectOrderParam2(order *mm_domain.Order) *mOrderRepositoryMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &OrderRepositoryMockUpdateOrderExpectation{}
	}

	if mmUpdateOrder.defaultExpectation.params != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Expect")
	}

	if mmUpdateOrder.defaultExpectation.paramPtrs == nil {
		mmUpdateOrder.defaultExpectation.paramPtrs = &OrderRepositoryMockUpdateOrderParamPtrs{}
	}
	mmUpdateOrder.defaultExpectation.paramPtrs.order = &order

	return mmUpdateOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.UpdateOrder
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Inspect(f func(ctx context.Context, order *mm_domain.Order)) *mOrderRepositoryMockUpdateOrder {
	if mmUpdateOrder.mock.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.UpdateOrder")
	}

	mmUpdateOrder.mock.inspectFuncUpdateOrder = f

	return mmUpdateOrder
}

// Return sets up results that will be returned by OrderRepository.UpdateOrder
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Return(err error) *OrderRepositoryMock {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &OrderRepositoryMockUpdateOrderExpectation{mock: mmUpdateOrder.mock}
	}
	mmUpdateOrder.defaultExpectation.results = &OrderRepositoryMockUpdateOrderResults{err}
	return mmUpdateOrder.mock
}

// Set uses given function f to mock the OrderRepository.UpdateOrder method
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Set(f func(ctx context.Context, order *mm_domain.Order) (err error)) *OrderRepositoryMock {
	if mmUpdateOrder.defaultExpectation != nil {
		mmUpdateOrder.mock.t.Fatalf("Default expectation is already set for the OrderRepository.UpdateOrder method")
	}

	if len(mmUpdateOrder.expectations) > 0 {
		mmUpdateOrder.mock.t.Fatalf("Some expectations are already set for the OrderRepository.UpdateOrder method")
	}

	mmUpdateOrder.mock.funcUpdateOrder = f
	return mmUpdateOrder.mock
}

// When sets expectation for the OrderRepository.UpdateOrder which will trigger the result defined by the following
// Then helper
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) When(ctx context.Context, order *mm_domain.Order) *OrderRepositoryMockUpdateOrderExpectation {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Set")
	}

	expectation := &OrderRepositoryMockUpdateOrderExpectation{
		mock:   mmUpdateOrder.mock,
		params: &OrderRepositoryMockUpdateOrderParams{ctx, order},
	}
	mmUpdateOrder.expectations = append(mmUpdateOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.UpdateOrder return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockUpdateOrderExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockUpdateOrderResults{err}
	return e.mock
}

// UpdateOrder implements domain.OrderRepository
func (mmUpdateOrder *OrderRepositoryMock) UpdateOrder(ctx context.Context, order *mm_domain.Order) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrder.beforeUpdateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrder.afterUpdateOrderCounter, 1)

	if mmUpdateOrder.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.inspectFuncUpdateOrder(ctx, order)
	}

	mm_params := OrderRepositoryMockUpdateOrderParams{ctx, order}

	// Record call args
	mmUpdateOrder.UpdateOrderMock.mutex.Lock()
	mmUpdateOrder.UpdateOrderMock.callArgs = append(mmUpdateOrder.UpdateOrderMock.callArgs, &mm_params)
	mmUpdateOrder.UpdateOrderMock.mutex.Unlock()

	for _, e := range mmUpdateOrder.UpdateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrder.UpdateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrder.UpdateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrder.UpdateOrderMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateOrder.UpdateOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockUpdateOrderParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateOrder.t.Errorf("OrderRepositoryMock.UpdateOrder got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmUpdateOrder.t.Errorf("OrderRepositoryMock.UpdateOrder got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrder.t.Errorf("OrderRepositoryMock.UpdateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrder.UpdateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrder.t.Fatal("No results are set for the OrderRepositoryMock.UpdateOrder")
		}
		return (*mm_results).err
	}
	if mmUpdateOrder.funcUpdateOrder != nil {
		return mmUpdateOrder.funcUpdateOrder(ctx, order)
	}
	mmUpdateOrder.t.Fatalf("Unexpected call to OrderRepositoryMock.UpdateOrder. %v %v", ctx, order)
	return
}

// UpdateOrderAfterCounter returns a count of finished OrderRepositoryMock.UpdateOrder invocations
func (mmUpdateOrder *OrderRepositoryMock) UpdateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.afterUpdateOrderCounter)
}

// UpdateOrderBeforeCounter returns a count of OrderRepositoryMock.UpdateOrder invocations
func (mmUpdateOrder *OrderRepositoryMock) UpdateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.beforeUpdateOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.UpdateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Calls() []*OrderRepositoryMockUpdateOrderParams {
	mmUpdateOrder.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockUpdateOrderParams, len(mmUpdateOrder.callArgs))
	copy(argCopy, mmUpdateOrder.callArgs)

	mmUpdateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderDone returns true if the count of the UpdateOrder invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockUpdateOrderDone() bool {
	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrder != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateOrderInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockUpdateOrderInspect() {
	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.UpdateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		if m.UpdateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.UpdateOrder")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.UpdateOrder with params: %#v", *m.UpdateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrder != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.UpdateOrder")
	}
}

type mOrderRepositoryMockUpdateOrderValidation struct {
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockUpdateOrderValidationExpectation
	expectations       []*OrderRepositoryMockUpdateOrderValidationExpectation

	callArgs []*OrderRepositoryMockUpdateOrderValidationParams
	mutex    sync.RWMutex
}

// OrderRepositoryMockUpdateOrderValidationExpectation specifies expectation struct of the OrderRepository.UpdateOrderValidation
type OrderRepositoryMockUpdateOrderValidationExpectation struct {
	mock      *OrderRepositoryMock
	params    *OrderRepositoryMockUpdateOrderValidationParams
	paramPtrs *OrderRepositoryMockUpdateOrderValidationParamPtrs
	results   *OrderRepositoryMockUpdateOrderValidationResults
	Counter   uint64
}

// OrderRepositoryMockUpdateOrderValidationParams contains parameters of the OrderRepository.UpdateOrderValidation
type OrderRepositoryMockUpdateOrderValidationParams struct {
	ctx             context.Context
	orderValidation *mm_domain.OrderValidation
}

// OrderRepositoryMockUpdateOrderValidationParamPtrs contains pointers to parameters of the OrderRepository.UpdateOrderValidation
type OrderRepositoryMockUpdateOrderValidationParamPtrs struct {
	ctx             *context.Context
	orderValidation **mm_domain.OrderValidation
}

// OrderRepositoryMockUpdateOrderValidationResults contains results of the OrderRepository.UpdateOrderValidation
type OrderRepositoryMockUpdateOrderValidationResults struct {
	err error
}

// Expect sets up expected params for OrderRepository.UpdateOrderValidation
func (mmUpdateOrderValidation *mOrderRepositoryMockUpdateOrderValidation) Expect(ctx context.Context, orderValidation *mm_domain.OrderValidation) *mOrderRepositoryMockUpdateOrderValidation {
	if mmUpdateOrderValidation.mock.funcUpdateOrderValidation != nil {
		mmUpdateOrderValidation.mock.t.Fatalf("OrderRepositoryMock.UpdateOrderValidation mock is already set by Set")
	}

	if mmUpdateOrderValidation.defaultExpectation == nil {
		mmUpdateOrderValidation.defaultExpectation = &OrderRepositoryMockUpdateOrderValidationExpectation{}
	}

	if mmUpdateOrderValidation.defaultExpectation.paramPtrs != nil {
		mmUpdateOrderValidation.mock.t.Fatalf("OrderRepositoryMock.UpdateOrderValidation mock is already set by ExpectParams functions")
	}

	mmUpdateOrderValidation.defaultExpectation.params = &OrderRepositoryMockUpdateOrderValidationParams{ctx, orderValidation}
	for _, e := range mmUpdateOrderValidation.expectations {
		if minimock.Equal(e.params, mmUpdateOrderValidation.defaultExpectation.params) {
			mmUpdateOrderValidation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrderValidation.defaultExpectation.params)
		}
	}

	return mmUpdateOrderValidation
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.UpdateOrderValidation
func (mmUpdateOrderValidation *mOrderRepositoryMockUpdateOrderValidation) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockUpdateOrderValidation {
	if mmUpdateOrderValidation.mock.funcUpdateOrderValidation != nil {
		mmUpdateOrderValidation.mock.t.Fatalf("OrderRepositoryMock.UpdateOrderValidation mock is already set by Set")
	}

	if mmUpdateOrderValidation.defaultExpectation == nil {
		mmUpdateOrderValidation.defaultExpectation = &OrderRepositoryMockUpdateOrderValidationExpectation{}
	}

	if mmUpdateOrderValidation.defaultExpectation.params != nil {
		mmUpdateOrderValidation.mock.t.Fatalf("OrderRepositoryMock.UpdateOrderValidation mock is already set by Expect")
	}

	if mmUpdateOrderValidation.defaultExpectation.paramPtrs == nil {
		mmUpdateOrderValidation.defaultExpectation.paramPtrs = &OrderRepositoryMockUpdateOrderValidationParamPtrs{}
	}
	mmUpdateOrderValidation.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateOrderValidation
}

// ExpectOrderValidationParam2 sets up expected param orderValidation for OrderRepository.UpdateOrderValidation
func (mmUpdateOrderValidation *mOrderRepositoryMockUpdateOrderValidation) ExpectOrderValidationParam2(orderValidation *mm_domain.OrderValidation) *mOrderRepositoryMockUpdateOrderValidation {
	if mmUpdateOrderValidation.mock.funcUpdateOrderValidation != nil {
		mmUpdateOrderValidation.mock.t.Fatalf("OrderRepositoryMock.UpdateOrderValidation mock is already set by Set")
	}

	if mmUpdateOrderValidation.defaultExpectation == nil {
		mmUpdateOrderValidation.defaultExpectation = &OrderRepositoryMockUpdateOrderValidationExpectation{}
	}

	if mmUpdateOrderValidation.defaultExpectation.params != nil {
		mmUpdateOrderValidation.mock.t.Fatalf("OrderRepositoryMock.UpdateOrderValidation mock is already set by Expect")
	}

	if mmUpdateOrderValidation.defaultExpectation.paramPtrs == nil {
		mmUpdateOrderValidation.defaultExpectation.paramPtrs = &OrderRepositoryMockUpdateOrderValidationParamPtrs{}
	}
	mmUpdateOrderValidation.defaultExpectation.paramPtrs.orderValidation = &orderValidation

	return mmUpdateOrderValidation
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.UpdateOrderValidation
func (mmUpdateOrderValidation *mOrderRepositoryMockUpdateOrderValidation) Inspect(f func(ctx context.Context, orderValidation *mm_domain.OrderValidation)) *mOrderRepositoryMockUpdateOrderValidation {
	if mmUpdateOrderValidation.mock.inspectFuncUpdateOrderValidation != nil {
		mmUpdateOrderValidation.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.UpdateOrderValidation")
	}

	mmUpdateOrderValidation.mock.inspectFuncUpdateOrderValidation = f

	return mmUpdateOrderValidation
}

// Return sets up results that will be returned by OrderRepository.UpdateOrderValidation
func (mmUpdateOrderValidation *mOrderRepositoryMockUpdateOrderValidation) Return(err error) *OrderRepositoryMock {
	if mmUpdateOrderValidation.mock.funcUpdateOrderValidation != nil {
		mmUpdateOrderValidation.mock.t.Fatalf("OrderRepositoryMock.UpdateOrderValidation mock is already set by Set")
	}

	if mmUpdateOrderValidation.defaultExpectation == nil {
		mmUpdateOrderValidation.defaultExpectation = &OrderRepositoryMockUpdateOrderValidationExpectation{mock: mmUpdateOrderValidation.mock}
	}
	mmUpdateOrderValidation.defaultExpectation.results = &OrderRepositoryMockUpdateOrderValidationResults{err}
	return mmUpdateOrderValidation.mock
}

// Set uses given function f to mock the OrderRepository.UpdateOrderValidation method
func (mmUpdateOrderValidation *mOrderRepositoryMockUpdateOrderValidation) Set(f func(ctx context.Context, orderValidation *mm_domain.OrderValidation) (err error)) *OrderRepositoryMock {
	if mmUpdateOrderValidation.defaultExpectation != nil {
		mmUpdateOrderValidation.mock.t.Fatalf("Default expectation is already set for the OrderRepository.UpdateOrderValidation method")
	}

	if len(mmUpdateOrderValidation.expectations) > 0 {
		mmUpdateOrderValidation.mock.t.Fatalf("Some expectations are already set for the OrderRepository.UpdateOrderValidation method")
	}

	mmUpdateOrderValidation.mock.funcUpdateOrderValidation = f
	return mmUpdateOrderValidation.mock
}

// When sets expectation for the OrderRepository.UpdateOrderValidation which will trigger the result defined by the following
// Then helper
func (mmUpdateOrderValidation *mOrderRepositoryMockUpdateOrderValidation) When(ctx context.Context, orderValidation *mm_domain.OrderValidation) *OrderRepositoryMockUpdateOrderValidationExpectation {
	if mmUpdateOrderValidation.mock.funcUpdateOrderValidation != nil {
		mmUpdateOrderValidation.mock.t.Fatalf("OrderRepositoryMock.UpdateOrderValidation mock is already set by Set")
	}

	expectation := &OrderRepositoryMockUpdateOrderValidationExpectation{
		mock:   mmUpdateOrderValidation.mock,
		params: &OrderRepositoryMockUpdateOrderValidationParams{ctx, orderValidation},
	}
	mmUpdateOrderValidation.expectations = append(mmUpdateOrderValidation.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.UpdateOrderValidation return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockUpdateOrderValidationExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockUpdateOrderValidationResults{err}
	return e.mock
}

// UpdateOrderValidation implements domain.OrderRepository
func (mmUpdateOrderValidation *OrderRepositoryMock) UpdateOrderValidation(ctx context.Context, orderValidation *mm_domain.OrderValidation) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrderValidation.beforeUpdateOrderValidationCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrderValidation.afterUpdateOrderValidationCounter, 1)

	if mmUpdateOrderValidation.inspectFuncUpdateOrderValidation != nil {
		mmUpdateOrderValidation.inspectFuncUpdateOrderValidation(ctx, orderValidation)
	}

	mm_params := OrderRepositoryMockUpdateOrderValidationParams{ctx, orderValidation}

	// Record call args
	mmUpdateOrderValidation.UpdateOrderValidationMock.mutex.Lock()
	mmUpdateOrderValidation.UpdateOrderValidationMock.callArgs = append(mmUpdateOrderValidation.UpdateOrderValidationMock.callArgs, &mm_params)
	mmUpdateOrderValidation.UpdateOrderValidationMock.mutex.Unlock()

	for _, e := range mmUpdateOrderValidation.UpdateOrderValidationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrderValidation.UpdateOrderValidationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrderValidation.UpdateOrderValidationMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrderValidation.UpdateOrderValidationMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateOrderValidation.UpdateOrderValidationMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockUpdateOrderValidationParams{ctx, orderValidation}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateOrderValidation.t.Errorf("OrderRepositoryMock.UpdateOrderValidation got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderValidation != nil && !minimock.Equal(*mm_want_ptrs.orderValidation, mm_got.orderValidation) {
				mmUpdateOrderValidation.t.Errorf("OrderRepositoryMock.UpdateOrderValidation got unexpected parameter orderValidation, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderValidation, mm_got.orderValidation, minimock.Diff(*mm_want_ptrs.orderValidation, mm_got.orderValidation))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrderValidation.t.Errorf("OrderRepositoryMock.UpdateOrderValidation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrderValidation.UpdateOrderValidationMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrderValidation.t.Fatal("No results are set for the OrderRepositoryMock.UpdateOrderValidation")
		}
		return (*mm_results).err
	}
	if mmUpdateOrderValidation.funcUpdateOrderValidation != nil {
		return mmUpdateOrderValidation.funcUpdateOrderValidation(ctx, orderValidation)
	}
	mmUpdateOrderValidation.t.Fatalf("Unexpected call to OrderRepositoryMock.UpdateOrderValidation. %v %v", ctx, orderValidation)
	return
}

// UpdateOrderValidationAfterCounter returns a count of finished OrderRepositoryMock.UpdateOrderValidation invocations
func (mmUpdateOrderValidation *OrderRepositoryMock) UpdateOrderValidationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderValidation.afterUpdateOrderValidationCounter)
}

// UpdateOrderValidationBeforeCounter returns a count of OrderRepositoryMock.UpdateOrderValidation invocations
func (mmUpdateOrderValidation *OrderRepositoryMock) UpdateOrderValidationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderValidation.beforeUpdateOrderValidationCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.UpdateOrderValidation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrderValidation *mOrderRepositoryMockUpdateOrderValidation) Calls() []*OrderRepositoryMockUpdateOrderValidationParams {
	mmUpdateOrderValidation.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockUpdateOrderValidationParams, len(mmUpdateOrderValidation.callArgs))
	copy(argCopy, mmUpdateOrderValidation.callArgs)

	mmUpdateOrderValidation.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderValidationDone returns true if the count of the UpdateOrderValidation invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockUpdateOrderValidationDone() bool {
	for _, e := range m.UpdateOrderValidationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderValidationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderValidationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderValidation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderValidationCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateOrderValidationInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockUpdateOrderValidationInspect() {
	for _, e := range m.UpdateOrderValidationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.UpdateOrderValidation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderValidationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderValidationCounter) < 1 {
		if m.UpdateOrderValidationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepositoryMock.UpdateOrderValidation")
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.UpdateOrderValidation with params: %#v", *m.UpdateOrderValidationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderValidation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderValidationCounter) < 1 {
		m.t.Error("Expected call to OrderRepositoryMock.UpdateOrderValidation")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetOrderByIDInspect()

			m.MinimockGetOrderValidationByIDInspect()

			m.MinimockSaveOrderInspect()

			m.MinimockSaveOrderValidationInspect()

			m.MinimockUpdateOrderInspect()

			m.MinimockUpdateOrderValidationInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetOrderByIDDone() &&
		m.MinimockGetOrderValidationByIDDone() &&
		m.MinimockSaveOrderDone() &&
		m.MinimockSaveOrderValidationDone() &&
		m.MinimockUpdateOrderDone() &&
		m.MinimockUpdateOrderValidationDone()
}
