// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/Sharykhin/go-delivery-dymas/pkg/http.HandlerInterface -o handler_interface_mock_test.go -n HandlerInterfaceMock -p mock

import (
	nethttp "net/http"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// HandlerInterfaceMock implements http.HandlerInterface
type HandlerInterfaceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDecodePayloadFromJson          func(r *nethttp.Request, requestData any) (err error)
	inspectFuncDecodePayloadFromJson   func(r *nethttp.Request, requestData any)
	afterDecodePayloadFromJsonCounter  uint64
	beforeDecodePayloadFromJsonCounter uint64
	DecodePayloadFromJsonMock          mHandlerInterfaceMockDecodePayloadFromJson

	funcFailResponse          func(w nethttp.ResponseWriter, errFailResponse error)
	inspectFuncFailResponse   func(w nethttp.ResponseWriter, errFailResponse error)
	afterFailResponseCounter  uint64
	beforeFailResponseCounter uint64
	FailResponseMock          mHandlerInterfaceMockFailResponse

	funcSuccessResponse          func(w nethttp.ResponseWriter, requestData any, status int)
	inspectFuncSuccessResponse   func(w nethttp.ResponseWriter, requestData any, status int)
	afterSuccessResponseCounter  uint64
	beforeSuccessResponseCounter uint64
	SuccessResponseMock          mHandlerInterfaceMockSuccessResponse

	funcValidatePayload          func(payload any) (err error)
	inspectFuncValidatePayload   func(payload any)
	afterValidatePayloadCounter  uint64
	beforeValidatePayloadCounter uint64
	ValidatePayloadMock          mHandlerInterfaceMockValidatePayload
}

// NewHandlerInterfaceMock returns a mock for http.HandlerInterface
func NewHandlerInterfaceMock(t minimock.Tester) *HandlerInterfaceMock {
	m := &HandlerInterfaceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DecodePayloadFromJsonMock = mHandlerInterfaceMockDecodePayloadFromJson{mock: m}
	m.DecodePayloadFromJsonMock.callArgs = []*HandlerInterfaceMockDecodePayloadFromJsonParams{}

	m.FailResponseMock = mHandlerInterfaceMockFailResponse{mock: m}
	m.FailResponseMock.callArgs = []*HandlerInterfaceMockFailResponseParams{}

	m.SuccessResponseMock = mHandlerInterfaceMockSuccessResponse{mock: m}
	m.SuccessResponseMock.callArgs = []*HandlerInterfaceMockSuccessResponseParams{}

	m.ValidatePayloadMock = mHandlerInterfaceMockValidatePayload{mock: m}
	m.ValidatePayloadMock.callArgs = []*HandlerInterfaceMockValidatePayloadParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mHandlerInterfaceMockDecodePayloadFromJson struct {
	mock               *HandlerInterfaceMock
	defaultExpectation *HandlerInterfaceMockDecodePayloadFromJsonExpectation
	expectations       []*HandlerInterfaceMockDecodePayloadFromJsonExpectation

	callArgs []*HandlerInterfaceMockDecodePayloadFromJsonParams
	mutex    sync.RWMutex
}

// HandlerInterfaceMockDecodePayloadFromJsonExpectation specifies expectation struct of the HandlerInterface.DecodePayloadFromJson
type HandlerInterfaceMockDecodePayloadFromJsonExpectation struct {
	mock      *HandlerInterfaceMock
	params    *HandlerInterfaceMockDecodePayloadFromJsonParams
	paramPtrs *HandlerInterfaceMockDecodePayloadFromJsonParamPtrs
	results   *HandlerInterfaceMockDecodePayloadFromJsonResults
	Counter   uint64
}

// HandlerInterfaceMockDecodePayloadFromJsonParams contains parameters of the HandlerInterface.DecodePayloadFromJson
type HandlerInterfaceMockDecodePayloadFromJsonParams struct {
	r           *nethttp.Request
	requestData any
}

// HandlerInterfaceMockDecodePayloadFromJsonParamPtrs contains pointers to parameters of the HandlerInterface.DecodePayloadFromJson
type HandlerInterfaceMockDecodePayloadFromJsonParamPtrs struct {
	r           **nethttp.Request
	requestData *any
}

// HandlerInterfaceMockDecodePayloadFromJsonResults contains results of the HandlerInterface.DecodePayloadFromJson
type HandlerInterfaceMockDecodePayloadFromJsonResults struct {
	err error
}

// Expect sets up expected params for HandlerInterface.DecodePayloadFromJson
func (mmDecodePayloadFromJson *mHandlerInterfaceMockDecodePayloadFromJson) Expect(r *nethttp.Request, requestData any) *mHandlerInterfaceMockDecodePayloadFromJson {
	if mmDecodePayloadFromJson.mock.funcDecodePayloadFromJson != nil {
		mmDecodePayloadFromJson.mock.t.Fatalf("HandlerInterfaceMock.DecodePayloadFromJson mock is already set by Set")
	}

	if mmDecodePayloadFromJson.defaultExpectation == nil {
		mmDecodePayloadFromJson.defaultExpectation = &HandlerInterfaceMockDecodePayloadFromJsonExpectation{}
	}

	if mmDecodePayloadFromJson.defaultExpectation.paramPtrs != nil {
		mmDecodePayloadFromJson.mock.t.Fatalf("HandlerInterfaceMock.DecodePayloadFromJson mock is already set by ExpectParams functions")
	}

	mmDecodePayloadFromJson.defaultExpectation.params = &HandlerInterfaceMockDecodePayloadFromJsonParams{r, requestData}
	for _, e := range mmDecodePayloadFromJson.expectations {
		if minimock.Equal(e.params, mmDecodePayloadFromJson.defaultExpectation.params) {
			mmDecodePayloadFromJson.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDecodePayloadFromJson.defaultExpectation.params)
		}
	}

	return mmDecodePayloadFromJson
}

// ExpectRParam1 sets up expected param r for HandlerInterface.DecodePayloadFromJson
func (mmDecodePayloadFromJson *mHandlerInterfaceMockDecodePayloadFromJson) ExpectRParam1(r *nethttp.Request) *mHandlerInterfaceMockDecodePayloadFromJson {
	if mmDecodePayloadFromJson.mock.funcDecodePayloadFromJson != nil {
		mmDecodePayloadFromJson.mock.t.Fatalf("HandlerInterfaceMock.DecodePayloadFromJson mock is already set by Set")
	}

	if mmDecodePayloadFromJson.defaultExpectation == nil {
		mmDecodePayloadFromJson.defaultExpectation = &HandlerInterfaceMockDecodePayloadFromJsonExpectation{}
	}

	if mmDecodePayloadFromJson.defaultExpectation.params != nil {
		mmDecodePayloadFromJson.mock.t.Fatalf("HandlerInterfaceMock.DecodePayloadFromJson mock is already set by Expect")
	}

	if mmDecodePayloadFromJson.defaultExpectation.paramPtrs == nil {
		mmDecodePayloadFromJson.defaultExpectation.paramPtrs = &HandlerInterfaceMockDecodePayloadFromJsonParamPtrs{}
	}
	mmDecodePayloadFromJson.defaultExpectation.paramPtrs.r = &r

	return mmDecodePayloadFromJson
}

// ExpectRequestDataParam2 sets up expected param requestData for HandlerInterface.DecodePayloadFromJson
func (mmDecodePayloadFromJson *mHandlerInterfaceMockDecodePayloadFromJson) ExpectRequestDataParam2(requestData any) *mHandlerInterfaceMockDecodePayloadFromJson {
	if mmDecodePayloadFromJson.mock.funcDecodePayloadFromJson != nil {
		mmDecodePayloadFromJson.mock.t.Fatalf("HandlerInterfaceMock.DecodePayloadFromJson mock is already set by Set")
	}

	if mmDecodePayloadFromJson.defaultExpectation == nil {
		mmDecodePayloadFromJson.defaultExpectation = &HandlerInterfaceMockDecodePayloadFromJsonExpectation{}
	}

	if mmDecodePayloadFromJson.defaultExpectation.params != nil {
		mmDecodePayloadFromJson.mock.t.Fatalf("HandlerInterfaceMock.DecodePayloadFromJson mock is already set by Expect")
	}

	if mmDecodePayloadFromJson.defaultExpectation.paramPtrs == nil {
		mmDecodePayloadFromJson.defaultExpectation.paramPtrs = &HandlerInterfaceMockDecodePayloadFromJsonParamPtrs{}
	}
	mmDecodePayloadFromJson.defaultExpectation.paramPtrs.requestData = &requestData

	return mmDecodePayloadFromJson
}

// Inspect accepts an inspector function that has same arguments as the HandlerInterface.DecodePayloadFromJson
func (mmDecodePayloadFromJson *mHandlerInterfaceMockDecodePayloadFromJson) Inspect(f func(r *nethttp.Request, requestData any)) *mHandlerInterfaceMockDecodePayloadFromJson {
	if mmDecodePayloadFromJson.mock.inspectFuncDecodePayloadFromJson != nil {
		mmDecodePayloadFromJson.mock.t.Fatalf("Inspect function is already set for HandlerInterfaceMock.DecodePayloadFromJson")
	}

	mmDecodePayloadFromJson.mock.inspectFuncDecodePayloadFromJson = f

	return mmDecodePayloadFromJson
}

// Return sets up results that will be returned by HandlerInterface.DecodePayloadFromJson
func (mmDecodePayloadFromJson *mHandlerInterfaceMockDecodePayloadFromJson) Return(err error) *HandlerInterfaceMock {
	if mmDecodePayloadFromJson.mock.funcDecodePayloadFromJson != nil {
		mmDecodePayloadFromJson.mock.t.Fatalf("HandlerInterfaceMock.DecodePayloadFromJson mock is already set by Set")
	}

	if mmDecodePayloadFromJson.defaultExpectation == nil {
		mmDecodePayloadFromJson.defaultExpectation = &HandlerInterfaceMockDecodePayloadFromJsonExpectation{mock: mmDecodePayloadFromJson.mock}
	}
	mmDecodePayloadFromJson.defaultExpectation.results = &HandlerInterfaceMockDecodePayloadFromJsonResults{err}
	return mmDecodePayloadFromJson.mock
}

// Set uses given function f to mock the HandlerInterface.DecodePayloadFromJson method
func (mmDecodePayloadFromJson *mHandlerInterfaceMockDecodePayloadFromJson) Set(f func(r *nethttp.Request, requestData any) (err error)) *HandlerInterfaceMock {
	if mmDecodePayloadFromJson.defaultExpectation != nil {
		mmDecodePayloadFromJson.mock.t.Fatalf("Default expectation is already set for the HandlerInterface.DecodePayloadFromJson method")
	}

	if len(mmDecodePayloadFromJson.expectations) > 0 {
		mmDecodePayloadFromJson.mock.t.Fatalf("Some expectations are already set for the HandlerInterface.DecodePayloadFromJson method")
	}

	mmDecodePayloadFromJson.mock.funcDecodePayloadFromJson = f
	return mmDecodePayloadFromJson.mock
}

// When sets expectation for the HandlerInterface.DecodePayloadFromJson which will trigger the result defined by the following
// Then helper
func (mmDecodePayloadFromJson *mHandlerInterfaceMockDecodePayloadFromJson) When(r *nethttp.Request, requestData any) *HandlerInterfaceMockDecodePayloadFromJsonExpectation {
	if mmDecodePayloadFromJson.mock.funcDecodePayloadFromJson != nil {
		mmDecodePayloadFromJson.mock.t.Fatalf("HandlerInterfaceMock.DecodePayloadFromJson mock is already set by Set")
	}

	expectation := &HandlerInterfaceMockDecodePayloadFromJsonExpectation{
		mock:   mmDecodePayloadFromJson.mock,
		params: &HandlerInterfaceMockDecodePayloadFromJsonParams{r, requestData},
	}
	mmDecodePayloadFromJson.expectations = append(mmDecodePayloadFromJson.expectations, expectation)
	return expectation
}

// Then sets up HandlerInterface.DecodePayloadFromJson return parameters for the expectation previously defined by the When method
func (e *HandlerInterfaceMockDecodePayloadFromJsonExpectation) Then(err error) *HandlerInterfaceMock {
	e.results = &HandlerInterfaceMockDecodePayloadFromJsonResults{err}
	return e.mock
}

// DecodePayloadFromJson implements http.HandlerInterface
func (mmDecodePayloadFromJson *HandlerInterfaceMock) DecodePayloadFromJson(r *nethttp.Request, requestData any) (err error) {
	mm_atomic.AddUint64(&mmDecodePayloadFromJson.beforeDecodePayloadFromJsonCounter, 1)
	defer mm_atomic.AddUint64(&mmDecodePayloadFromJson.afterDecodePayloadFromJsonCounter, 1)

	if mmDecodePayloadFromJson.inspectFuncDecodePayloadFromJson != nil {
		mmDecodePayloadFromJson.inspectFuncDecodePayloadFromJson(r, requestData)
	}

	mm_params := HandlerInterfaceMockDecodePayloadFromJsonParams{r, requestData}

	// Record call args
	mmDecodePayloadFromJson.DecodePayloadFromJsonMock.mutex.Lock()
	mmDecodePayloadFromJson.DecodePayloadFromJsonMock.callArgs = append(mmDecodePayloadFromJson.DecodePayloadFromJsonMock.callArgs, &mm_params)
	mmDecodePayloadFromJson.DecodePayloadFromJsonMock.mutex.Unlock()

	for _, e := range mmDecodePayloadFromJson.DecodePayloadFromJsonMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDecodePayloadFromJson.DecodePayloadFromJsonMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDecodePayloadFromJson.DecodePayloadFromJsonMock.defaultExpectation.Counter, 1)
		mm_want := mmDecodePayloadFromJson.DecodePayloadFromJsonMock.defaultExpectation.params
		mm_want_ptrs := mmDecodePayloadFromJson.DecodePayloadFromJsonMock.defaultExpectation.paramPtrs

		mm_got := HandlerInterfaceMockDecodePayloadFromJsonParams{r, requestData}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.r != nil && !minimock.Equal(*mm_want_ptrs.r, mm_got.r) {
				mmDecodePayloadFromJson.t.Errorf("HandlerInterfaceMock.DecodePayloadFromJson got unexpected parameter r, want: %#v, got: %#v%s\n", *mm_want_ptrs.r, mm_got.r, minimock.Diff(*mm_want_ptrs.r, mm_got.r))
			}

			if mm_want_ptrs.requestData != nil && !minimock.Equal(*mm_want_ptrs.requestData, mm_got.requestData) {
				mmDecodePayloadFromJson.t.Errorf("HandlerInterfaceMock.DecodePayloadFromJson got unexpected parameter requestData, want: %#v, got: %#v%s\n", *mm_want_ptrs.requestData, mm_got.requestData, minimock.Diff(*mm_want_ptrs.requestData, mm_got.requestData))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDecodePayloadFromJson.t.Errorf("HandlerInterfaceMock.DecodePayloadFromJson got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDecodePayloadFromJson.DecodePayloadFromJsonMock.defaultExpectation.results
		if mm_results == nil {
			mmDecodePayloadFromJson.t.Fatal("No results are set for the HandlerInterfaceMock.DecodePayloadFromJson")
		}
		return (*mm_results).err
	}
	if mmDecodePayloadFromJson.funcDecodePayloadFromJson != nil {
		return mmDecodePayloadFromJson.funcDecodePayloadFromJson(r, requestData)
	}
	mmDecodePayloadFromJson.t.Fatalf("Unexpected call to HandlerInterfaceMock.DecodePayloadFromJson. %v %v", r, requestData)
	return
}

// DecodePayloadFromJsonAfterCounter returns a count of finished HandlerInterfaceMock.DecodePayloadFromJson invocations
func (mmDecodePayloadFromJson *HandlerInterfaceMock) DecodePayloadFromJsonAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecodePayloadFromJson.afterDecodePayloadFromJsonCounter)
}

// DecodePayloadFromJsonBeforeCounter returns a count of HandlerInterfaceMock.DecodePayloadFromJson invocations
func (mmDecodePayloadFromJson *HandlerInterfaceMock) DecodePayloadFromJsonBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecodePayloadFromJson.beforeDecodePayloadFromJsonCounter)
}

// Calls returns a list of arguments used in each call to HandlerInterfaceMock.DecodePayloadFromJson.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDecodePayloadFromJson *mHandlerInterfaceMockDecodePayloadFromJson) Calls() []*HandlerInterfaceMockDecodePayloadFromJsonParams {
	mmDecodePayloadFromJson.mutex.RLock()

	argCopy := make([]*HandlerInterfaceMockDecodePayloadFromJsonParams, len(mmDecodePayloadFromJson.callArgs))
	copy(argCopy, mmDecodePayloadFromJson.callArgs)

	mmDecodePayloadFromJson.mutex.RUnlock()

	return argCopy
}

// MinimockDecodePayloadFromJsonDone returns true if the count of the DecodePayloadFromJson invocations corresponds
// the number of defined expectations
func (m *HandlerInterfaceMock) MinimockDecodePayloadFromJsonDone() bool {
	for _, e := range m.DecodePayloadFromJsonMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DecodePayloadFromJsonMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDecodePayloadFromJsonCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDecodePayloadFromJson != nil && mm_atomic.LoadUint64(&m.afterDecodePayloadFromJsonCounter) < 1 {
		return false
	}
	return true
}

// MinimockDecodePayloadFromJsonInspect logs each unmet expectation
func (m *HandlerInterfaceMock) MinimockDecodePayloadFromJsonInspect() {
	for _, e := range m.DecodePayloadFromJsonMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HandlerInterfaceMock.DecodePayloadFromJson with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DecodePayloadFromJsonMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDecodePayloadFromJsonCounter) < 1 {
		if m.DecodePayloadFromJsonMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HandlerInterfaceMock.DecodePayloadFromJson")
		} else {
			m.t.Errorf("Expected call to HandlerInterfaceMock.DecodePayloadFromJson with params: %#v", *m.DecodePayloadFromJsonMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDecodePayloadFromJson != nil && mm_atomic.LoadUint64(&m.afterDecodePayloadFromJsonCounter) < 1 {
		m.t.Error("Expected call to HandlerInterfaceMock.DecodePayloadFromJson")
	}
}

type mHandlerInterfaceMockFailResponse struct {
	mock               *HandlerInterfaceMock
	defaultExpectation *HandlerInterfaceMockFailResponseExpectation
	expectations       []*HandlerInterfaceMockFailResponseExpectation

	callArgs []*HandlerInterfaceMockFailResponseParams
	mutex    sync.RWMutex
}

// HandlerInterfaceMockFailResponseExpectation specifies expectation struct of the HandlerInterface.FailResponse
type HandlerInterfaceMockFailResponseExpectation struct {
	mock      *HandlerInterfaceMock
	params    *HandlerInterfaceMockFailResponseParams
	paramPtrs *HandlerInterfaceMockFailResponseParamPtrs

	Counter uint64
}

// HandlerInterfaceMockFailResponseParams contains parameters of the HandlerInterface.FailResponse
type HandlerInterfaceMockFailResponseParams struct {
	w               nethttp.ResponseWriter
	errFailResponse error
}

// HandlerInterfaceMockFailResponseParamPtrs contains pointers to parameters of the HandlerInterface.FailResponse
type HandlerInterfaceMockFailResponseParamPtrs struct {
	w               *nethttp.ResponseWriter
	errFailResponse *error
}

// Expect sets up expected params for HandlerInterface.FailResponse
func (mmFailResponse *mHandlerInterfaceMockFailResponse) Expect(w nethttp.ResponseWriter, errFailResponse error) *mHandlerInterfaceMockFailResponse {
	if mmFailResponse.mock.funcFailResponse != nil {
		mmFailResponse.mock.t.Fatalf("HandlerInterfaceMock.FailResponse mock is already set by Set")
	}

	if mmFailResponse.defaultExpectation == nil {
		mmFailResponse.defaultExpectation = &HandlerInterfaceMockFailResponseExpectation{}
	}

	if mmFailResponse.defaultExpectation.paramPtrs != nil {
		mmFailResponse.mock.t.Fatalf("HandlerInterfaceMock.FailResponse mock is already set by ExpectParams functions")
	}

	mmFailResponse.defaultExpectation.params = &HandlerInterfaceMockFailResponseParams{w, errFailResponse}
	for _, e := range mmFailResponse.expectations {
		if minimock.Equal(e.params, mmFailResponse.defaultExpectation.params) {
			mmFailResponse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFailResponse.defaultExpectation.params)
		}
	}

	return mmFailResponse
}

// ExpectWParam1 sets up expected param w for HandlerInterface.FailResponse
func (mmFailResponse *mHandlerInterfaceMockFailResponse) ExpectWParam1(w nethttp.ResponseWriter) *mHandlerInterfaceMockFailResponse {
	if mmFailResponse.mock.funcFailResponse != nil {
		mmFailResponse.mock.t.Fatalf("HandlerInterfaceMock.FailResponse mock is already set by Set")
	}

	if mmFailResponse.defaultExpectation == nil {
		mmFailResponse.defaultExpectation = &HandlerInterfaceMockFailResponseExpectation{}
	}

	if mmFailResponse.defaultExpectation.params != nil {
		mmFailResponse.mock.t.Fatalf("HandlerInterfaceMock.FailResponse mock is already set by Expect")
	}

	if mmFailResponse.defaultExpectation.paramPtrs == nil {
		mmFailResponse.defaultExpectation.paramPtrs = &HandlerInterfaceMockFailResponseParamPtrs{}
	}
	mmFailResponse.defaultExpectation.paramPtrs.w = &w

	return mmFailResponse
}

// ExpectErrFailResponseParam2 sets up expected param errFailResponse for HandlerInterface.FailResponse
func (mmFailResponse *mHandlerInterfaceMockFailResponse) ExpectErrFailResponseParam2(errFailResponse error) *mHandlerInterfaceMockFailResponse {
	if mmFailResponse.mock.funcFailResponse != nil {
		mmFailResponse.mock.t.Fatalf("HandlerInterfaceMock.FailResponse mock is already set by Set")
	}

	if mmFailResponse.defaultExpectation == nil {
		mmFailResponse.defaultExpectation = &HandlerInterfaceMockFailResponseExpectation{}
	}

	if mmFailResponse.defaultExpectation.params != nil {
		mmFailResponse.mock.t.Fatalf("HandlerInterfaceMock.FailResponse mock is already set by Expect")
	}

	if mmFailResponse.defaultExpectation.paramPtrs == nil {
		mmFailResponse.defaultExpectation.paramPtrs = &HandlerInterfaceMockFailResponseParamPtrs{}
	}
	mmFailResponse.defaultExpectation.paramPtrs.errFailResponse = &errFailResponse

	return mmFailResponse
}

// Inspect accepts an inspector function that has same arguments as the HandlerInterface.FailResponse
func (mmFailResponse *mHandlerInterfaceMockFailResponse) Inspect(f func(w nethttp.ResponseWriter, errFailResponse error)) *mHandlerInterfaceMockFailResponse {
	if mmFailResponse.mock.inspectFuncFailResponse != nil {
		mmFailResponse.mock.t.Fatalf("Inspect function is already set for HandlerInterfaceMock.FailResponse")
	}

	mmFailResponse.mock.inspectFuncFailResponse = f

	return mmFailResponse
}

// Return sets up results that will be returned by HandlerInterface.FailResponse
func (mmFailResponse *mHandlerInterfaceMockFailResponse) Return() *HandlerInterfaceMock {
	if mmFailResponse.mock.funcFailResponse != nil {
		mmFailResponse.mock.t.Fatalf("HandlerInterfaceMock.FailResponse mock is already set by Set")
	}

	if mmFailResponse.defaultExpectation == nil {
		mmFailResponse.defaultExpectation = &HandlerInterfaceMockFailResponseExpectation{mock: mmFailResponse.mock}
	}

	return mmFailResponse.mock
}

// Set uses given function f to mock the HandlerInterface.FailResponse method
func (mmFailResponse *mHandlerInterfaceMockFailResponse) Set(f func(w nethttp.ResponseWriter, errFailResponse error)) *HandlerInterfaceMock {
	if mmFailResponse.defaultExpectation != nil {
		mmFailResponse.mock.t.Fatalf("Default expectation is already set for the HandlerInterface.FailResponse method")
	}

	if len(mmFailResponse.expectations) > 0 {
		mmFailResponse.mock.t.Fatalf("Some expectations are already set for the HandlerInterface.FailResponse method")
	}

	mmFailResponse.mock.funcFailResponse = f
	return mmFailResponse.mock
}

// FailResponse implements http.HandlerInterface
func (mmFailResponse *HandlerInterfaceMock) FailResponse(w nethttp.ResponseWriter, errFailResponse error) {
	mm_atomic.AddUint64(&mmFailResponse.beforeFailResponseCounter, 1)
	defer mm_atomic.AddUint64(&mmFailResponse.afterFailResponseCounter, 1)

	if mmFailResponse.inspectFuncFailResponse != nil {
		mmFailResponse.inspectFuncFailResponse(w, errFailResponse)
	}

	mm_params := HandlerInterfaceMockFailResponseParams{w, errFailResponse}

	// Record call args
	mmFailResponse.FailResponseMock.mutex.Lock()
	mmFailResponse.FailResponseMock.callArgs = append(mmFailResponse.FailResponseMock.callArgs, &mm_params)
	mmFailResponse.FailResponseMock.mutex.Unlock()

	for _, e := range mmFailResponse.FailResponseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFailResponse.FailResponseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFailResponse.FailResponseMock.defaultExpectation.Counter, 1)
		mm_want := mmFailResponse.FailResponseMock.defaultExpectation.params
		mm_want_ptrs := mmFailResponse.FailResponseMock.defaultExpectation.paramPtrs

		mm_got := HandlerInterfaceMockFailResponseParams{w, errFailResponse}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.w != nil && !minimock.Equal(*mm_want_ptrs.w, mm_got.w) {
				mmFailResponse.t.Errorf("HandlerInterfaceMock.FailResponse got unexpected parameter w, want: %#v, got: %#v%s\n", *mm_want_ptrs.w, mm_got.w, minimock.Diff(*mm_want_ptrs.w, mm_got.w))
			}

			if mm_want_ptrs.errFailResponse != nil && !minimock.Equal(*mm_want_ptrs.errFailResponse, mm_got.errFailResponse) {
				mmFailResponse.t.Errorf("HandlerInterfaceMock.FailResponse got unexpected parameter errFailResponse, want: %#v, got: %#v%s\n", *mm_want_ptrs.errFailResponse, mm_got.errFailResponse, minimock.Diff(*mm_want_ptrs.errFailResponse, mm_got.errFailResponse))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFailResponse.t.Errorf("HandlerInterfaceMock.FailResponse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmFailResponse.funcFailResponse != nil {
		mmFailResponse.funcFailResponse(w, errFailResponse)
		return
	}
	mmFailResponse.t.Fatalf("Unexpected call to HandlerInterfaceMock.FailResponse. %v %v", w, errFailResponse)

}

// FailResponseAfterCounter returns a count of finished HandlerInterfaceMock.FailResponse invocations
func (mmFailResponse *HandlerInterfaceMock) FailResponseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFailResponse.afterFailResponseCounter)
}

// FailResponseBeforeCounter returns a count of HandlerInterfaceMock.FailResponse invocations
func (mmFailResponse *HandlerInterfaceMock) FailResponseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFailResponse.beforeFailResponseCounter)
}

// Calls returns a list of arguments used in each call to HandlerInterfaceMock.FailResponse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFailResponse *mHandlerInterfaceMockFailResponse) Calls() []*HandlerInterfaceMockFailResponseParams {
	mmFailResponse.mutex.RLock()

	argCopy := make([]*HandlerInterfaceMockFailResponseParams, len(mmFailResponse.callArgs))
	copy(argCopy, mmFailResponse.callArgs)

	mmFailResponse.mutex.RUnlock()

	return argCopy
}

// MinimockFailResponseDone returns true if the count of the FailResponse invocations corresponds
// the number of defined expectations
func (m *HandlerInterfaceMock) MinimockFailResponseDone() bool {
	for _, e := range m.FailResponseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FailResponseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFailResponseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFailResponse != nil && mm_atomic.LoadUint64(&m.afterFailResponseCounter) < 1 {
		return false
	}
	return true
}

// MinimockFailResponseInspect logs each unmet expectation
func (m *HandlerInterfaceMock) MinimockFailResponseInspect() {
	for _, e := range m.FailResponseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HandlerInterfaceMock.FailResponse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FailResponseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFailResponseCounter) < 1 {
		if m.FailResponseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HandlerInterfaceMock.FailResponse")
		} else {
			m.t.Errorf("Expected call to HandlerInterfaceMock.FailResponse with params: %#v", *m.FailResponseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFailResponse != nil && mm_atomic.LoadUint64(&m.afterFailResponseCounter) < 1 {
		m.t.Error("Expected call to HandlerInterfaceMock.FailResponse")
	}
}

type mHandlerInterfaceMockSuccessResponse struct {
	mock               *HandlerInterfaceMock
	defaultExpectation *HandlerInterfaceMockSuccessResponseExpectation
	expectations       []*HandlerInterfaceMockSuccessResponseExpectation

	callArgs []*HandlerInterfaceMockSuccessResponseParams
	mutex    sync.RWMutex
}

// HandlerInterfaceMockSuccessResponseExpectation specifies expectation struct of the HandlerInterface.SuccessResponse
type HandlerInterfaceMockSuccessResponseExpectation struct {
	mock      *HandlerInterfaceMock
	params    *HandlerInterfaceMockSuccessResponseParams
	paramPtrs *HandlerInterfaceMockSuccessResponseParamPtrs

	Counter uint64
}

// HandlerInterfaceMockSuccessResponseParams contains parameters of the HandlerInterface.SuccessResponse
type HandlerInterfaceMockSuccessResponseParams struct {
	w           nethttp.ResponseWriter
	requestData any
	status      int
}

// HandlerInterfaceMockSuccessResponseParamPtrs contains pointers to parameters of the HandlerInterface.SuccessResponse
type HandlerInterfaceMockSuccessResponseParamPtrs struct {
	w           *nethttp.ResponseWriter
	requestData *any
	status      *int
}

// Expect sets up expected params for HandlerInterface.SuccessResponse
func (mmSuccessResponse *mHandlerInterfaceMockSuccessResponse) Expect(w nethttp.ResponseWriter, requestData any, status int) *mHandlerInterfaceMockSuccessResponse {
	if mmSuccessResponse.mock.funcSuccessResponse != nil {
		mmSuccessResponse.mock.t.Fatalf("HandlerInterfaceMock.SuccessResponse mock is already set by Set")
	}

	if mmSuccessResponse.defaultExpectation == nil {
		mmSuccessResponse.defaultExpectation = &HandlerInterfaceMockSuccessResponseExpectation{}
	}

	if mmSuccessResponse.defaultExpectation.paramPtrs != nil {
		mmSuccessResponse.mock.t.Fatalf("HandlerInterfaceMock.SuccessResponse mock is already set by ExpectParams functions")
	}

	mmSuccessResponse.defaultExpectation.params = &HandlerInterfaceMockSuccessResponseParams{w, requestData, status}
	for _, e := range mmSuccessResponse.expectations {
		if minimock.Equal(e.params, mmSuccessResponse.defaultExpectation.params) {
			mmSuccessResponse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSuccessResponse.defaultExpectation.params)
		}
	}

	return mmSuccessResponse
}

// ExpectWParam1 sets up expected param w for HandlerInterface.SuccessResponse
func (mmSuccessResponse *mHandlerInterfaceMockSuccessResponse) ExpectWParam1(w nethttp.ResponseWriter) *mHandlerInterfaceMockSuccessResponse {
	if mmSuccessResponse.mock.funcSuccessResponse != nil {
		mmSuccessResponse.mock.t.Fatalf("HandlerInterfaceMock.SuccessResponse mock is already set by Set")
	}

	if mmSuccessResponse.defaultExpectation == nil {
		mmSuccessResponse.defaultExpectation = &HandlerInterfaceMockSuccessResponseExpectation{}
	}

	if mmSuccessResponse.defaultExpectation.params != nil {
		mmSuccessResponse.mock.t.Fatalf("HandlerInterfaceMock.SuccessResponse mock is already set by Expect")
	}

	if mmSuccessResponse.defaultExpectation.paramPtrs == nil {
		mmSuccessResponse.defaultExpectation.paramPtrs = &HandlerInterfaceMockSuccessResponseParamPtrs{}
	}
	mmSuccessResponse.defaultExpectation.paramPtrs.w = &w

	return mmSuccessResponse
}

// ExpectRequestDataParam2 sets up expected param requestData for HandlerInterface.SuccessResponse
func (mmSuccessResponse *mHandlerInterfaceMockSuccessResponse) ExpectRequestDataParam2(requestData any) *mHandlerInterfaceMockSuccessResponse {
	if mmSuccessResponse.mock.funcSuccessResponse != nil {
		mmSuccessResponse.mock.t.Fatalf("HandlerInterfaceMock.SuccessResponse mock is already set by Set")
	}

	if mmSuccessResponse.defaultExpectation == nil {
		mmSuccessResponse.defaultExpectation = &HandlerInterfaceMockSuccessResponseExpectation{}
	}

	if mmSuccessResponse.defaultExpectation.params != nil {
		mmSuccessResponse.mock.t.Fatalf("HandlerInterfaceMock.SuccessResponse mock is already set by Expect")
	}

	if mmSuccessResponse.defaultExpectation.paramPtrs == nil {
		mmSuccessResponse.defaultExpectation.paramPtrs = &HandlerInterfaceMockSuccessResponseParamPtrs{}
	}
	mmSuccessResponse.defaultExpectation.paramPtrs.requestData = &requestData

	return mmSuccessResponse
}

// ExpectStatusParam3 sets up expected param status for HandlerInterface.SuccessResponse
func (mmSuccessResponse *mHandlerInterfaceMockSuccessResponse) ExpectStatusParam3(status int) *mHandlerInterfaceMockSuccessResponse {
	if mmSuccessResponse.mock.funcSuccessResponse != nil {
		mmSuccessResponse.mock.t.Fatalf("HandlerInterfaceMock.SuccessResponse mock is already set by Set")
	}

	if mmSuccessResponse.defaultExpectation == nil {
		mmSuccessResponse.defaultExpectation = &HandlerInterfaceMockSuccessResponseExpectation{}
	}

	if mmSuccessResponse.defaultExpectation.params != nil {
		mmSuccessResponse.mock.t.Fatalf("HandlerInterfaceMock.SuccessResponse mock is already set by Expect")
	}

	if mmSuccessResponse.defaultExpectation.paramPtrs == nil {
		mmSuccessResponse.defaultExpectation.paramPtrs = &HandlerInterfaceMockSuccessResponseParamPtrs{}
	}
	mmSuccessResponse.defaultExpectation.paramPtrs.status = &status

	return mmSuccessResponse
}

// Inspect accepts an inspector function that has same arguments as the HandlerInterface.SuccessResponse
func (mmSuccessResponse *mHandlerInterfaceMockSuccessResponse) Inspect(f func(w nethttp.ResponseWriter, requestData any, status int)) *mHandlerInterfaceMockSuccessResponse {
	if mmSuccessResponse.mock.inspectFuncSuccessResponse != nil {
		mmSuccessResponse.mock.t.Fatalf("Inspect function is already set for HandlerInterfaceMock.SuccessResponse")
	}

	mmSuccessResponse.mock.inspectFuncSuccessResponse = f

	return mmSuccessResponse
}

// Return sets up results that will be returned by HandlerInterface.SuccessResponse
func (mmSuccessResponse *mHandlerInterfaceMockSuccessResponse) Return() *HandlerInterfaceMock {
	if mmSuccessResponse.mock.funcSuccessResponse != nil {
		mmSuccessResponse.mock.t.Fatalf("HandlerInterfaceMock.SuccessResponse mock is already set by Set")
	}

	if mmSuccessResponse.defaultExpectation == nil {
		mmSuccessResponse.defaultExpectation = &HandlerInterfaceMockSuccessResponseExpectation{mock: mmSuccessResponse.mock}
	}

	return mmSuccessResponse.mock
}

// Set uses given function f to mock the HandlerInterface.SuccessResponse method
func (mmSuccessResponse *mHandlerInterfaceMockSuccessResponse) Set(f func(w nethttp.ResponseWriter, requestData any, status int)) *HandlerInterfaceMock {
	if mmSuccessResponse.defaultExpectation != nil {
		mmSuccessResponse.mock.t.Fatalf("Default expectation is already set for the HandlerInterface.SuccessResponse method")
	}

	if len(mmSuccessResponse.expectations) > 0 {
		mmSuccessResponse.mock.t.Fatalf("Some expectations are already set for the HandlerInterface.SuccessResponse method")
	}

	mmSuccessResponse.mock.funcSuccessResponse = f
	return mmSuccessResponse.mock
}

// SuccessResponse implements http.HandlerInterface
func (mmSuccessResponse *HandlerInterfaceMock) SuccessResponse(w nethttp.ResponseWriter, requestData any, status int) {
	mm_atomic.AddUint64(&mmSuccessResponse.beforeSuccessResponseCounter, 1)
	defer mm_atomic.AddUint64(&mmSuccessResponse.afterSuccessResponseCounter, 1)

	if mmSuccessResponse.inspectFuncSuccessResponse != nil {
		mmSuccessResponse.inspectFuncSuccessResponse(w, requestData, status)
	}

	mm_params := HandlerInterfaceMockSuccessResponseParams{w, requestData, status}

	// Record call args
	mmSuccessResponse.SuccessResponseMock.mutex.Lock()
	mmSuccessResponse.SuccessResponseMock.callArgs = append(mmSuccessResponse.SuccessResponseMock.callArgs, &mm_params)
	mmSuccessResponse.SuccessResponseMock.mutex.Unlock()

	for _, e := range mmSuccessResponse.SuccessResponseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSuccessResponse.SuccessResponseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSuccessResponse.SuccessResponseMock.defaultExpectation.Counter, 1)
		mm_want := mmSuccessResponse.SuccessResponseMock.defaultExpectation.params
		mm_want_ptrs := mmSuccessResponse.SuccessResponseMock.defaultExpectation.paramPtrs

		mm_got := HandlerInterfaceMockSuccessResponseParams{w, requestData, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.w != nil && !minimock.Equal(*mm_want_ptrs.w, mm_got.w) {
				mmSuccessResponse.t.Errorf("HandlerInterfaceMock.SuccessResponse got unexpected parameter w, want: %#v, got: %#v%s\n", *mm_want_ptrs.w, mm_got.w, minimock.Diff(*mm_want_ptrs.w, mm_got.w))
			}

			if mm_want_ptrs.requestData != nil && !minimock.Equal(*mm_want_ptrs.requestData, mm_got.requestData) {
				mmSuccessResponse.t.Errorf("HandlerInterfaceMock.SuccessResponse got unexpected parameter requestData, want: %#v, got: %#v%s\n", *mm_want_ptrs.requestData, mm_got.requestData, minimock.Diff(*mm_want_ptrs.requestData, mm_got.requestData))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmSuccessResponse.t.Errorf("HandlerInterfaceMock.SuccessResponse got unexpected parameter status, want: %#v, got: %#v%s\n", *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSuccessResponse.t.Errorf("HandlerInterfaceMock.SuccessResponse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSuccessResponse.funcSuccessResponse != nil {
		mmSuccessResponse.funcSuccessResponse(w, requestData, status)
		return
	}
	mmSuccessResponse.t.Fatalf("Unexpected call to HandlerInterfaceMock.SuccessResponse. %v %v %v", w, requestData, status)

}

// SuccessResponseAfterCounter returns a count of finished HandlerInterfaceMock.SuccessResponse invocations
func (mmSuccessResponse *HandlerInterfaceMock) SuccessResponseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSuccessResponse.afterSuccessResponseCounter)
}

// SuccessResponseBeforeCounter returns a count of HandlerInterfaceMock.SuccessResponse invocations
func (mmSuccessResponse *HandlerInterfaceMock) SuccessResponseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSuccessResponse.beforeSuccessResponseCounter)
}

// Calls returns a list of arguments used in each call to HandlerInterfaceMock.SuccessResponse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSuccessResponse *mHandlerInterfaceMockSuccessResponse) Calls() []*HandlerInterfaceMockSuccessResponseParams {
	mmSuccessResponse.mutex.RLock()

	argCopy := make([]*HandlerInterfaceMockSuccessResponseParams, len(mmSuccessResponse.callArgs))
	copy(argCopy, mmSuccessResponse.callArgs)

	mmSuccessResponse.mutex.RUnlock()

	return argCopy
}

// MinimockSuccessResponseDone returns true if the count of the SuccessResponse invocations corresponds
// the number of defined expectations
func (m *HandlerInterfaceMock) MinimockSuccessResponseDone() bool {
	for _, e := range m.SuccessResponseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SuccessResponseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSuccessResponseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSuccessResponse != nil && mm_atomic.LoadUint64(&m.afterSuccessResponseCounter) < 1 {
		return false
	}
	return true
}

// MinimockSuccessResponseInspect logs each unmet expectation
func (m *HandlerInterfaceMock) MinimockSuccessResponseInspect() {
	for _, e := range m.SuccessResponseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HandlerInterfaceMock.SuccessResponse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SuccessResponseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSuccessResponseCounter) < 1 {
		if m.SuccessResponseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HandlerInterfaceMock.SuccessResponse")
		} else {
			m.t.Errorf("Expected call to HandlerInterfaceMock.SuccessResponse with params: %#v", *m.SuccessResponseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSuccessResponse != nil && mm_atomic.LoadUint64(&m.afterSuccessResponseCounter) < 1 {
		m.t.Error("Expected call to HandlerInterfaceMock.SuccessResponse")
	}
}

type mHandlerInterfaceMockValidatePayload struct {
	mock               *HandlerInterfaceMock
	defaultExpectation *HandlerInterfaceMockValidatePayloadExpectation
	expectations       []*HandlerInterfaceMockValidatePayloadExpectation

	callArgs []*HandlerInterfaceMockValidatePayloadParams
	mutex    sync.RWMutex
}

// HandlerInterfaceMockValidatePayloadExpectation specifies expectation struct of the HandlerInterface.ValidatePayload
type HandlerInterfaceMockValidatePayloadExpectation struct {
	mock      *HandlerInterfaceMock
	params    *HandlerInterfaceMockValidatePayloadParams
	paramPtrs *HandlerInterfaceMockValidatePayloadParamPtrs
	results   *HandlerInterfaceMockValidatePayloadResults
	Counter   uint64
}

// HandlerInterfaceMockValidatePayloadParams contains parameters of the HandlerInterface.ValidatePayload
type HandlerInterfaceMockValidatePayloadParams struct {
	payload any
}

// HandlerInterfaceMockValidatePayloadParamPtrs contains pointers to parameters of the HandlerInterface.ValidatePayload
type HandlerInterfaceMockValidatePayloadParamPtrs struct {
	payload *any
}

// HandlerInterfaceMockValidatePayloadResults contains results of the HandlerInterface.ValidatePayload
type HandlerInterfaceMockValidatePayloadResults struct {
	err error
}

// Expect sets up expected params for HandlerInterface.ValidatePayload
func (mmValidatePayload *mHandlerInterfaceMockValidatePayload) Expect(payload any) *mHandlerInterfaceMockValidatePayload {
	if mmValidatePayload.mock.funcValidatePayload != nil {
		mmValidatePayload.mock.t.Fatalf("HandlerInterfaceMock.ValidatePayload mock is already set by Set")
	}

	if mmValidatePayload.defaultExpectation == nil {
		mmValidatePayload.defaultExpectation = &HandlerInterfaceMockValidatePayloadExpectation{}
	}

	if mmValidatePayload.defaultExpectation.paramPtrs != nil {
		mmValidatePayload.mock.t.Fatalf("HandlerInterfaceMock.ValidatePayload mock is already set by ExpectParams functions")
	}

	mmValidatePayload.defaultExpectation.params = &HandlerInterfaceMockValidatePayloadParams{payload}
	for _, e := range mmValidatePayload.expectations {
		if minimock.Equal(e.params, mmValidatePayload.defaultExpectation.params) {
			mmValidatePayload.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidatePayload.defaultExpectation.params)
		}
	}

	return mmValidatePayload
}

// ExpectPayloadParam1 sets up expected param payload for HandlerInterface.ValidatePayload
func (mmValidatePayload *mHandlerInterfaceMockValidatePayload) ExpectPayloadParam1(payload any) *mHandlerInterfaceMockValidatePayload {
	if mmValidatePayload.mock.funcValidatePayload != nil {
		mmValidatePayload.mock.t.Fatalf("HandlerInterfaceMock.ValidatePayload mock is already set by Set")
	}

	if mmValidatePayload.defaultExpectation == nil {
		mmValidatePayload.defaultExpectation = &HandlerInterfaceMockValidatePayloadExpectation{}
	}

	if mmValidatePayload.defaultExpectation.params != nil {
		mmValidatePayload.mock.t.Fatalf("HandlerInterfaceMock.ValidatePayload mock is already set by Expect")
	}

	if mmValidatePayload.defaultExpectation.paramPtrs == nil {
		mmValidatePayload.defaultExpectation.paramPtrs = &HandlerInterfaceMockValidatePayloadParamPtrs{}
	}
	mmValidatePayload.defaultExpectation.paramPtrs.payload = &payload

	return mmValidatePayload
}

// Inspect accepts an inspector function that has same arguments as the HandlerInterface.ValidatePayload
func (mmValidatePayload *mHandlerInterfaceMockValidatePayload) Inspect(f func(payload any)) *mHandlerInterfaceMockValidatePayload {
	if mmValidatePayload.mock.inspectFuncValidatePayload != nil {
		mmValidatePayload.mock.t.Fatalf("Inspect function is already set for HandlerInterfaceMock.ValidatePayload")
	}

	mmValidatePayload.mock.inspectFuncValidatePayload = f

	return mmValidatePayload
}

// Return sets up results that will be returned by HandlerInterface.ValidatePayload
func (mmValidatePayload *mHandlerInterfaceMockValidatePayload) Return(err error) *HandlerInterfaceMock {
	if mmValidatePayload.mock.funcValidatePayload != nil {
		mmValidatePayload.mock.t.Fatalf("HandlerInterfaceMock.ValidatePayload mock is already set by Set")
	}

	if mmValidatePayload.defaultExpectation == nil {
		mmValidatePayload.defaultExpectation = &HandlerInterfaceMockValidatePayloadExpectation{mock: mmValidatePayload.mock}
	}
	mmValidatePayload.defaultExpectation.results = &HandlerInterfaceMockValidatePayloadResults{err}
	return mmValidatePayload.mock
}

// Set uses given function f to mock the HandlerInterface.ValidatePayload method
func (mmValidatePayload *mHandlerInterfaceMockValidatePayload) Set(f func(payload any) (err error)) *HandlerInterfaceMock {
	if mmValidatePayload.defaultExpectation != nil {
		mmValidatePayload.mock.t.Fatalf("Default expectation is already set for the HandlerInterface.ValidatePayload method")
	}

	if len(mmValidatePayload.expectations) > 0 {
		mmValidatePayload.mock.t.Fatalf("Some expectations are already set for the HandlerInterface.ValidatePayload method")
	}

	mmValidatePayload.mock.funcValidatePayload = f
	return mmValidatePayload.mock
}

// When sets expectation for the HandlerInterface.ValidatePayload which will trigger the result defined by the following
// Then helper
func (mmValidatePayload *mHandlerInterfaceMockValidatePayload) When(payload any) *HandlerInterfaceMockValidatePayloadExpectation {
	if mmValidatePayload.mock.funcValidatePayload != nil {
		mmValidatePayload.mock.t.Fatalf("HandlerInterfaceMock.ValidatePayload mock is already set by Set")
	}

	expectation := &HandlerInterfaceMockValidatePayloadExpectation{
		mock:   mmValidatePayload.mock,
		params: &HandlerInterfaceMockValidatePayloadParams{payload},
	}
	mmValidatePayload.expectations = append(mmValidatePayload.expectations, expectation)
	return expectation
}

// Then sets up HandlerInterface.ValidatePayload return parameters for the expectation previously defined by the When method
func (e *HandlerInterfaceMockValidatePayloadExpectation) Then(err error) *HandlerInterfaceMock {
	e.results = &HandlerInterfaceMockValidatePayloadResults{err}
	return e.mock
}

// ValidatePayload implements http.HandlerInterface
func (mmValidatePayload *HandlerInterfaceMock) ValidatePayload(payload any) (err error) {
	mm_atomic.AddUint64(&mmValidatePayload.beforeValidatePayloadCounter, 1)
	defer mm_atomic.AddUint64(&mmValidatePayload.afterValidatePayloadCounter, 1)

	if mmValidatePayload.inspectFuncValidatePayload != nil {
		mmValidatePayload.inspectFuncValidatePayload(payload)
	}

	mm_params := HandlerInterfaceMockValidatePayloadParams{payload}

	// Record call args
	mmValidatePayload.ValidatePayloadMock.mutex.Lock()
	mmValidatePayload.ValidatePayloadMock.callArgs = append(mmValidatePayload.ValidatePayloadMock.callArgs, &mm_params)
	mmValidatePayload.ValidatePayloadMock.mutex.Unlock()

	for _, e := range mmValidatePayload.ValidatePayloadMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmValidatePayload.ValidatePayloadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidatePayload.ValidatePayloadMock.defaultExpectation.Counter, 1)
		mm_want := mmValidatePayload.ValidatePayloadMock.defaultExpectation.params
		mm_want_ptrs := mmValidatePayload.ValidatePayloadMock.defaultExpectation.paramPtrs

		mm_got := HandlerInterfaceMockValidatePayloadParams{payload}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.payload != nil && !minimock.Equal(*mm_want_ptrs.payload, mm_got.payload) {
				mmValidatePayload.t.Errorf("HandlerInterfaceMock.ValidatePayload got unexpected parameter payload, want: %#v, got: %#v%s\n", *mm_want_ptrs.payload, mm_got.payload, minimock.Diff(*mm_want_ptrs.payload, mm_got.payload))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidatePayload.t.Errorf("HandlerInterfaceMock.ValidatePayload got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidatePayload.ValidatePayloadMock.defaultExpectation.results
		if mm_results == nil {
			mmValidatePayload.t.Fatal("No results are set for the HandlerInterfaceMock.ValidatePayload")
		}
		return (*mm_results).err
	}
	if mmValidatePayload.funcValidatePayload != nil {
		return mmValidatePayload.funcValidatePayload(payload)
	}
	mmValidatePayload.t.Fatalf("Unexpected call to HandlerInterfaceMock.ValidatePayload. %v", payload)
	return
}

// ValidatePayloadAfterCounter returns a count of finished HandlerInterfaceMock.ValidatePayload invocations
func (mmValidatePayload *HandlerInterfaceMock) ValidatePayloadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidatePayload.afterValidatePayloadCounter)
}

// ValidatePayloadBeforeCounter returns a count of HandlerInterfaceMock.ValidatePayload invocations
func (mmValidatePayload *HandlerInterfaceMock) ValidatePayloadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidatePayload.beforeValidatePayloadCounter)
}

// Calls returns a list of arguments used in each call to HandlerInterfaceMock.ValidatePayload.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidatePayload *mHandlerInterfaceMockValidatePayload) Calls() []*HandlerInterfaceMockValidatePayloadParams {
	mmValidatePayload.mutex.RLock()

	argCopy := make([]*HandlerInterfaceMockValidatePayloadParams, len(mmValidatePayload.callArgs))
	copy(argCopy, mmValidatePayload.callArgs)

	mmValidatePayload.mutex.RUnlock()

	return argCopy
}

// MinimockValidatePayloadDone returns true if the count of the ValidatePayload invocations corresponds
// the number of defined expectations
func (m *HandlerInterfaceMock) MinimockValidatePayloadDone() bool {
	for _, e := range m.ValidatePayloadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ValidatePayloadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterValidatePayloadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidatePayload != nil && mm_atomic.LoadUint64(&m.afterValidatePayloadCounter) < 1 {
		return false
	}
	return true
}

// MinimockValidatePayloadInspect logs each unmet expectation
func (m *HandlerInterfaceMock) MinimockValidatePayloadInspect() {
	for _, e := range m.ValidatePayloadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HandlerInterfaceMock.ValidatePayload with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ValidatePayloadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterValidatePayloadCounter) < 1 {
		if m.ValidatePayloadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HandlerInterfaceMock.ValidatePayload")
		} else {
			m.t.Errorf("Expected call to HandlerInterfaceMock.ValidatePayload with params: %#v", *m.ValidatePayloadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidatePayload != nil && mm_atomic.LoadUint64(&m.afterValidatePayloadCounter) < 1 {
		m.t.Error("Expected call to HandlerInterfaceMock.ValidatePayload")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *HandlerInterfaceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDecodePayloadFromJsonInspect()

			m.MinimockFailResponseInspect()

			m.MinimockSuccessResponseInspect()

			m.MinimockValidatePayloadInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *HandlerInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *HandlerInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDecodePayloadFromJsonDone() &&
		m.MinimockFailResponseDone() &&
		m.MinimockSuccessResponseDone() &&
		m.MinimockValidatePayloadDone()
}
